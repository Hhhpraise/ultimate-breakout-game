<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ultimate Breakout Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            width: 100%;
            max-width: 820px;
            height: 100vh;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e);
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
            flex: 1;
            max-width: 100%;
            height: auto;
        }

        .ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }

        .controls {
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.3;
        }

        .mobile-controls {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-top: 10px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .control-group {
            display: flex;
            gap: 20px;
        }

        .laser-button {
            background: linear-gradient(45deg, #00d2d3, #0099cc);
            font-size: 20px;
        }

        .pause-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            font-size: 16px;
        }

        .sound-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            font-size: 20px;
        }

        .sound-button.muted {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
            width: 80%;
            max-width: 400px;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .btn:hover, .btn:active {
            transform: scale(1.05);
        }

        .wave-indicator {
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 8px;
        }

        .power-up-indicator {
            font-size: 12px;
            color: #00ff88;
            margin-bottom: 5px;
            min-height: 18px;
        }

        .legend {
            margin-top: 8px;
            font-size: 10px;
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 6px;
            border-radius: 6px;
            max-height: 120px;
            overflow-y: auto;
        }

        .legend-item {
            margin: 1px 0;
            display: flex;
            align-items: center;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            margin-right: 4px;
            border-radius: 2px;
        }

        .combo-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            color: white;
            z-index: 999;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
        }

        .pause-content {
            text-align: center;
            padding: 20px;
        }

        .pause-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .pause-subtitle {
            font-size: 18px;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        .resume-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .resume-btn:hover, .resume-btn:active {
            transform: scale(1.05);
        }

        .wave-transition {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            color: white;
            text-align: center;
        }

        .wave-transition h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .wave-transition p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .wave-progress {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .wave-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d2d3, #ffd700);
            width: 0%;
            transition: width 0.1s ease;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            text-align: center;
        }

        .start-screen h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .start-screen p {
            margin: 10px 0;
            max-width: 600px;
            line-height: 1.6;
        }

        .best-score {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 50px;
            margin: 20px 0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ff88;
        }

        .footer {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .footer a {
            color: #00d2d3;
            text-decoration: none;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
        }

        .footer a:hover {
            color: #ff6b6b;
            transform: translateY(-2px);
        }

        .footer a i {
            font-size: 1.2rem;
        }

        .sound-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s;
            z-index: 200;
        }

        .sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .sound-toggle:active {
            transform: scale(0.95);
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .game-container {
                padding: 5px;
                border-radius: 0;
                height: 100vh;
            }

            .mobile-controls {
                display: flex;
            }

            .ui {
                font-size: 14px;
            }

            .wave-indicator {
                font-size: 12px;
            }

            .power-up-indicator {
                font-size: 10px;
            }

            .legend {
                font-size: 9px;
                max-height: 80px;
            }

            .combo-indicator {
                font-size: 16px;
                top: 10px;
                right: 10px;
            }

            .pause-overlay {
                font-size: 28px;
            }

            .pause-title {
                font-size: 36px;
            }

            .pause-subtitle {
                font-size: 16px;
            }

            .wave-transition h2 {
                font-size: 2rem;
            }

            .wave-transition p {
                font-size: 1rem;
            }

            .wave-progress {
                width: 250px;
            }

            .start-screen h1 {
                font-size: 1.8rem;
            }

            .start-screen p {
                font-size: 0.9rem;
            }

            .best-score {
                font-size: 1.2rem;
                padding: 10px 20px;
            }

            .footer {
                flex-direction: column;
                gap: 15px;
                margin-top: 15px;
            }

            .btn {
                padding: 12px 24px;
                font-size: 18px;
            }

            .sound-toggle {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }

        @media (max-height: 600px) {
            .legend {
                max-height: 60px;
            }

            .controls {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <button class="sound-toggle" id="soundToggle">üîä</button>

        <div class="start-screen" id="startScreen">
            <h1>ULTIMATE BREAKOUT</h1>
            <p>Destroy all bricks without losing your balls! Collect power-ups for special abilities.</p>

            <div class="best-score">Best Score: <span id="bestScore">0</span></div>

            <button class="btn" id="startBtn">START GAME</button>

            <div class="footer">
                <a href="https://hhhpraise.github.io/portfolio/" target="_blank">
                    <i>üë®‚Äçüíª</i> My Portfolio
                </a>
                <a href="mailto:hhhpraise33@gmail.com">
                    <i>‚úâÔ∏è</i> Send Suggestions
                </a>
            </div>
        </div>

        <div class="wave-transition" id="waveTransition">
            <h2 id="waveTransitionTitle">Wave 1</h2>
            <p id="waveTransitionText">Get Ready!</p>
            <div class="wave-progress">
                <div class="wave-progress-bar" id="waveProgressBar"></div>
            </div>
        </div>

        <div class="wave-indicator">Wave: <span id="wave">1</span></div>
        <div class="power-up-indicator" id="powerUpStatus"></div>
        <div class="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Combo: <span id="combo">0</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>

        <div class="controls" id="desktopControls">
            Use ‚Üê ‚Üí arrow keys or A/D to move ‚Ä¢ SPACE to shoot laser ‚Ä¢ P to pause
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-group">
                <button class="control-button" id="leftBtn">‚Üê</button>
                <button class="control-button" id="rightBtn">‚Üí</button>
            </div>
            <div class="control-group">
                <button class="control-button laser-button" id="laserBtn">‚ö°</button>
                <button class="control-button pause-button" id="pauseBtn">‚è∏</button>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>Normal (10pts)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffd700;"></div>
                <span>Strong (25pts, 2 hits)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #c0c0c0;"></div>
                <span>Metal (50pts, 3 hits)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff4757;"></div>
                <span>Explosive (75pts, destroys nearby)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2f3542;"></div>
                <span>Unbreakable (blocks balls)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff88;"></div>
                <span>üéÅ Power-ups: = (Wide) O (Big) + (Life) * (Multi) ‚ö° (Laser) üî• (Fire)</span>
            </div>
        </div>

        <div class="combo-indicator" id="comboDisplay" style="display: none;"></div>

        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-content">
                <div class="pause-title">PAUSED</div>
                <div class="pause-subtitle">Tap anywhere or click the button to resume</div>
                <button class="resume-btn" id="resumeBtn">RESUME GAME</button>
            </div>
        </div>

        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Wave Reached: <span id="finalWave">1</span></p>
            <p>Max Combo: <span id="maxCombo">0</span></p>
            <p>Best Score: <span id="gameOverBestScore">0</span></p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <canvas id="exportCanvas" style="display: none;"></canvas>

    <script>
        // Color Theory Algorithms
        class ColorTheory {
            static hexToHsl(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return [h * 360, s * 100, l * 100];
            }

            static hslToHex(h, s, l) {
                h = h % 360;
                s = s / 100;
                l = l / 100;

                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;
                let r = 0, g = 0, b = 0;

                if (0 <= h && h < 60) {
                    r = c; g = x; b = 0;
                } else if (60 <= h && h < 120) {
                    r = x; g = c; b = 0;
                } else if (120 <= h && h < 180) {
                    r = 0; g = c; b = x;
                } else if (180 <= h && h < 240) {
                    r = 0; g = x; b = c;
                } else if (240 <= h && h < 300) {
                    r = x; g = 0; b = c;
                } else if (300 <= h && h < 360) {
                    r = c; g = 0; b = x;
                }

                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);

                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            static complementary(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    baseColor,
                    this.hslToHex((h + 180) % 360, s, l),
                    this.hslToHex(h, Math.max(20, s - 20), Math.min(80, l + 10)),
                    this.hslToHex((h + 180) % 360, Math.max(20, s - 20), Math.min(80, l + 10))
                ];
            }

            static analogous(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    this.hslToHex((h - 30 + 360) % 360, s, l),
                    baseColor,
                    this.hslToHex((h + 30) % 360, s, l),
                    this.hslToHex((h + 60) % 360, s, l)
                ];
            }

            static triadic(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    baseColor,
                    this.hslToHex((h + 120) % 360, s, l),
                    this.hslToHex((h + 240) % 360, s, l),
                    this.hslToHex(h, Math.max(30, s - 20), Math.min(85, l + 15))
                ];
            }

            static monochromatic(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    this.hslToHex(h, s, Math.min(90, l + 30)),
                    this.hslToHex(h, s, Math.min(80, l + 15)),
                    baseColor,
                    this.hslToHex(h, s, Math.max(20, l - 15))
                ];
            }
        }

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         ('ontouchstart' in window) ||
                         (navigator.maxTouchPoints > 0);

        // Sound management
        let soundEnabled = true;
        const soundToggle = document.getElementById('soundToggle');

        function updateSoundToggle() {
            soundToggle.textContent = soundEnabled ? 'üîä' : 'üîá';
            soundToggle.classList.toggle('muted', !soundEnabled);
        }

        soundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            soundEnabled = !soundEnabled;
            updateSoundToggle();
        });

        updateSoundToggle();

        // Canvas setup with responsive sizing
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerRect = container.getBoundingClientRect();

            if (isMobile) {
                canvas.width = Math.min(containerRect.width - 16, 800);
                canvas.height = Math.min(containerRect.height - 200, 500);
            } else {
                canvas.width = 800;
                canvas.height = 600;
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI elements
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const comboElement = document.getElementById('combo');
        const waveElement = document.getElementById('wave');
        const powerUpStatusElement = document.getElementById('powerUpStatus');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const finalWaveElement = document.getElementById('finalWave');
        const maxComboElement = document.getElementById('maxCombo');
        const gameOverBestScoreElement = document.getElementById('gameOverBestScore');
        const comboDisplayElement = document.getElementById('comboDisplay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const bestScoreElement = document.getElementById('bestScore');
        const waveTransition = document.getElementById('waveTransition');
        const waveTransitionTitle = document.getElementById('waveTransitionTitle');
        const waveTransitionText = document.getElementById('waveTransitionText');
        const waveProgressBar = document.getElementById('waveProgressBar');

        // Load best score
        let bestScore = 0;
        bestScoreElement.textContent = bestScore;

        // Show/hide controls based on device
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'flex';
            document.getElementById('desktopControls').style.display = 'none';
        }

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let waveTransitioning = false;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let combo = 0;
        let maxCombo = 0;
        let lastHitTime = 0;
        let currentWaveColors = ['#ff6b6b', '#4ecdc4', '#ffd700', '#c0c0c0'];

        // Particles system
        let particles = [];
        let explosions = [];

        // Sound effects using Web Audio API
        let audioContext;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            // Fallback for browsers without Web Audio API
            audioContext = null;
        }

        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;

                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Silent fail for audio context issues
            }
        }

        // Paddle
        const paddle = {
            x: 0,
            y: 0,
            width: 120,
            height: 15,
            speed: 8,
            originalWidth: 120,
            color: '#fff',
            trail: []
        };

        // Ball
        const ball = {
            x: 0,
            y: 0,
            radius: 8,
            dx: 4,
            dy: -4,
            speed: 4,
            originalRadius: 8,
            trail: [],
            fireBall: false,
            stuckCounter: 0
        };

        // Initialize positions based on canvas size
        function initializePositions() {
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.y = canvas.height - 30;
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
        }

        initializePositions();

        // Lasers
        let lasers = [];
        let canShootLaser = false;
        let laserCooldown = 0;

        // Power-ups with proper pause handling
        let powerUps = [];
        let activePowerUps = {
            widePaddle: 0,
            bigBall: 0,
            extraLife: false,
            multiball: [],
            laser: 0,
            fireBall: 0
        };

        // Store remaining time when paused - FIXED
        let pausedPowerUpTimes = {
            widePaddle: 0,
            bigBall: 0,
            laser: 0,
            fireBall: 0
        };

        const powerUpTypes = [
            { type: 'widePaddle', color: '#ff6b6b', symbol: '=', duration: 15000 },
            { type: 'bigBall', color: '#4ecdc4', symbol: 'O', duration: 12000 },
            { type: 'extraLife', color: '#ffd700', symbol: '+', duration: 0 },
            { type: 'multiball', color: '#ff9ff3', symbol: '*', duration: 0 },
            { type: 'laser', color: '#00d2d3', symbol: '‚ö°', duration: 20000 },
            { type: 'fireBall', color: '#ff4757', symbol: 'üî•', duration: 15000 }
        ];

        // Bricks
        let bricks = [];
        let animatingBricks = [];
        const brickRows = isMobile ? 5 : 6;
        const brickCols = isMobile ? 8 : 10;
        let brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;

        function calculateBrickDimensions() {
            brickWidth = (canvas.width - 70) / brickCols;
            brickHeight = isMobile ? 18 : 20;
            brickPadding = 5;
            brickOffsetTop = 60;
            brickOffsetLeft = 35;
        }

        calculateBrickDimensions();

        // Brick types with dynamic colors
        function getBrickTypes() {
            return {
                normal: { color: currentWaveColors[0], hits: 1, points: 10 },
                strong: { color: currentWaveColors[1], hits: 2, points: 25 },
                metal: { color: currentWaveColors[2], hits: 3, points: 50 },
                explosive: { color: '#ff4757', hits: 1, points: 75 },
                unbreakable: { color: '#2f3542', hits: -1, points: 0 }
            };
        }

        // Input handling
        const keys = {};
        let touchControls = {
            left: false,
            right: false
        };

        // Desktop controls
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                shootLaser();
            }
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Mobile controls
        if (isMobile) {
            // Touch controls for movement
            let touchStartX = 0;
            let touchCurrentX = 0;
            let isTouching = false;

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchCurrentX = touch.clientX;
                isTouching = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isTouching) {
                    const touch = e.touches[0];
                    touchCurrentX = touch.clientX;

                    const deltaX = touchCurrentX - touchStartX;
                    const sensitivity = 2;
                    paddle.x += deltaX * sensitivity;

                    // Keep paddle within bounds
                    paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

                    touchStartX = touchCurrentX;
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouching = false;
            });

            // Button controls
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const laserBtn = document.getElementById('laserBtn');
            const pauseBtn = document.getElementById('pauseBtn');

            // Movement buttons
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.left = true;
            });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls.left = false;
            });

            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.right = true;
            });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls.right = false;
            });

            // Laser button
            laserBtn.addEventListener('click', (e) => {
                e.preventDefault();
                shootLaser();
            });

            // Pause button
            pauseBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                togglePause();
            });

            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function generateWaveColors() {
            // Generate a random base color for each wave
            const baseHue = (wave * 137.5) % 360; // Golden angle for good distribution
            const baseColor = ColorTheory.hslToHex(baseHue, 70, 50);

            // Use different color schemes for variety
            const schemes = ['complementary', 'analogous', 'triadic', 'monochromatic'];
            const scheme = schemes[wave % schemes.length];

            switch (scheme) {
                case 'complementary':
                    currentWaveColors = ColorTheory.complementary(baseColor);
                    break;
                case 'analogous':
                    currentWaveColors = ColorTheory.analogous(baseColor);
                    break;
                case 'triadic':
                    currentWaveColors = ColorTheory.triadic(baseColor);
                    break;
                case 'monochromatic':
                    currentWaveColors = ColorTheory.monochromatic(baseColor);
                    break;
            }
        }

        function updateCanvasBackground() {
            // Update the canvas background gradient based on wave colors
            const canvasStyle = canvas.style;
            canvasStyle.background = `linear-gradient(45deg, ${currentWaveColors[0]}15, ${currentWaveColors[1]}15)`;
        }

        // FIXED: Proper power-up pause/resume handling
        function pausePowerUps() {
            const now = Date.now();
            if (activePowerUps.widePaddle > now) {
                pausedPowerUpTimes.widePaddle = activePowerUps.widePaddle - now;
                activePowerUps.widePaddle = 0; // Clear the active timer
            }
            if (activePowerUps.bigBall > now) {
                pausedPowerUpTimes.bigBall = activePowerUps.bigBall - now;
                activePowerUps.bigBall = 0;
            }
            if (activePowerUps.laser > now) {
                pausedPowerUpTimes.laser = activePowerUps.laser - now;
                activePowerUps.laser = 0;
            }
            if (activePowerUps.fireBall > now) {
                pausedPowerUpTimes.fireBall = activePowerUps.fireBall - now;
                activePowerUps.fireBall = 0;
            }
        }

        function resumePowerUps() {
            const now = Date.now();
            if (pausedPowerUpTimes.widePaddle > 0) {
                activePowerUps.widePaddle = now + pausedPowerUpTimes.widePaddle;
                pausedPowerUpTimes.widePaddle = 0;
            }
            if (pausedPowerUpTimes.bigBall > 0) {
                activePowerUps.bigBall = now + pausedPowerUpTimes.bigBall;
                pausedPowerUpTimes.bigBall = 0;
            }
            if (pausedPowerUpTimes.laser > 0) {
                activePowerUps.laser = now + pausedPowerUpTimes.laser;
                pausedPowerUpTimes.laser = 0;
            }
            if (pausedPowerUpTimes.fireBall > 0) {
                activePowerUps.fireBall = now + pausedPowerUpTimes.fireBall;
                pausedPowerUpTimes.fireBall = 0;
            }
        }

        function togglePause() {
            if (!gameRunning || waveTransitioning) return;

            gamePaused = !gamePaused;
            pauseOverlay.style.display = gamePaused ? 'flex' : 'none';

            if (gamePaused) {
                pausePowerUps();
            } else {
                resumePowerUps();
                // Resume audio context if needed
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
        }

        // Pause overlay click/touch handlers
        pauseOverlay.addEventListener('click', (e) => {
            if (gamePaused) {
                togglePause();
            }
        });

        pauseOverlay.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gamePaused) {
                togglePause();
            }
        });

        // Resume button
        resumeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gamePaused) {
                togglePause();
            }
        });

        resumeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (gamePaused) {
                togglePause();
            }
        });

        function startGame() {
            gameRunning = true;
            startScreen.style.display = 'none';
            restartGame();
        }

        // Start button event listener
        startBtn.addEventListener('click', startGame);

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 60,
                life: 1,
                decay: 0.05
            });

            // Create shockwave particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * 6,
                    dy: Math.sin(angle) * 6,
                    color: '#ff4757',
                    life: 1,
                    decay: 0.03,
                    size: 3
                });
            }
        }

        function shootLaser() {
            if (canShootLaser && laserCooldown <= 0 && gameRunning && !gamePaused && !waveTransitioning) {
                lasers.push({
                    x: paddle.x + paddle.width / 2 - 2,
                    y: paddle.y,
                    width: 4,
                    height: 20,
                    dy: -15
                });
                laserCooldown = 15; // Cooldown frames
                playSound(1000, 0.1, 'square', 0.05);
            }
        }

        function generateBrickPattern() {
            // Create different brick patterns for variety
            const patterns = [
                'solid', 'checkerboard', 'pyramid', 'diamond', 'cross', 'waves', 'random'
            ];
            const pattern = patterns[wave % patterns.length];
            const brickPositions = [];

            switch (pattern) {
                case 'solid':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            brickPositions.push({row: r, col: c});
                        }
                    }
                    break;

                case 'checkerboard':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if ((r + c) % 2 === 0) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'pyramid':
                    for (let r = 0; r < brickRows; r++) {
                        const bricksInRow = Math.max(1, brickCols - r * 2);
                        const startCol = Math.floor((brickCols - bricksInRow) / 2);
                        for (let i = 0; i < bricksInRow; i++) {
                            brickPositions.push({row: r, col: startCol + i});
                        }
                    }
                    break;

                case 'diamond':
                    const centerRow = Math.floor(brickRows / 2);
                    for (let r = 0; r < brickRows; r++) {
                        const distFromCenter = Math.abs(r - centerRow);
                        const bricksInRow = Math.max(1, brickCols - distFromCenter * 2);
                        const startCol = Math.floor((brickCols - bricksInRow) / 2);
                        for (let i = 0; i < bricksInRow; i++) {
                            brickPositions.push({row: r, col: startCol + i});
                        }
                    }
                    break;

                case 'cross':
                    const centerCol = Math.floor(brickCols / 2);
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (r === centerRow || c === centerCol ||
                                Math.abs(r - centerRow) === Math.abs(c - centerCol)) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'waves':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (Math.sin(c * 0.8 + r * 0.5) > -0.3) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'random':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (Math.random() > 0.3) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;
            }

            return brickPositions;
        }

        // WAVE TRANSITION ANIMATION - NEW
        function startWaveTransition() {
            waveTransitioning = true;
            waveTransition.style.display = 'flex';
            waveTransitionTitle.textContent = `Wave ${wave}`;

            const messages = [
                'Get Ready!',
                'Prepare for Battle!',
                'Incoming Bricks!',
                'Power Up!',
                'Stay Alert!',
                'Here We Go!',
                'Brace Yourself!'
            ];
            waveTransitionText.textContent = messages[Math.floor(Math.random() * messages.length)];

            // Generate new wave colors
            generateWaveColors();
            updateCanvasBackground();

            // Animate progress bar
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 2;
                waveProgressBar.style.width = progress + '%';

                if (progress >= 100) {
                    clearInterval(progressInterval);
                    setTimeout(() => {
                        waveTransition.style.display = 'none';
                        waveTransitioning = false;
                        createBricks(); // Create bricks after transition
                    }, 500);
                }
            }, 30);
        }

        function createBricks() {
            bricks = [];
            animatingBricks = [];
            calculateBrickDimensions();
            const brickTypes = getBrickTypes();
            const positions = generateBrickPattern();

            positions.forEach((pos, index) => {
                let type = 'normal';

                // Add variety based on wave and position
                if (wave >= 2 && Math.random() < 0.25) {
                    type = 'strong';
                }
                if (wave >= 3 && Math.random() < 0.15) {
                    type = 'metal';
                }
                if (wave >= 4 && Math.random() < 0.1) {
                    type = 'explosive';
                }
                if (wave >= 5 && Math.random() < 0.05) {
                    type = 'unbreakable';
                }

                const brickType = brickTypes[type];
                const targetX = pos.col * (brickWidth + brickPadding) + brickOffsetLeft;
                const targetY = pos.row * (brickHeight + brickPadding) + brickOffsetTop;

                // Create brick with animation properties
                const brick = {
                    x: targetX,
                    y: -brickHeight, // Start above screen
                    targetX: targetX,
                    targetY: targetY,
                    width: brickWidth,
                    height: brickHeight,
                    type: type,
                    color: brickType.color,
                    maxHits: brickType.hits,
                    hits: brickType.hits,
                    points: brickType.points,
                    visible: true,
                    animating: true,
                    animationDelay: index * 50, // Stagger the animation
                    animationProgress: 0
                };

                bricks.push(brick);
                animatingBricks.push(brick);
            });
        }

        function animateBricksIn() {
            animatingBricks.forEach((brick, index) => {
                if (brick.animationDelay > 0) {
                    brick.animationDelay -= 16; // Roughly 60fps
                    return;
                }

                brick.animationProgress += 0.05;
                if (brick.animationProgress >= 1) {
                    brick.animationProgress = 1;
                    brick.animating = false;
                    brick.y = brick.targetY;
                } else {
                    // Easing function for smooth animation
                    const easeOut = 1 - Math.pow(1 - brick.animationProgress, 3);
                    brick.y = -brick.height + (brick.targetY + brick.height) * easeOut;
                }
            });

            // Remove finished animations
            animatingBricks = animatingBricks.filter(brick => brick.animating);
        }

        function createPowerUp(x, y) {
            if (Math.random() < 0.25) { // 25% chance for power-up
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUps.push({
                    x: x,
                    y: y,
                    width: 20,
                    height: 20,
                    dy: 2,
                    type: powerUpType.type,
                    color: powerUpType.color,
                    symbol: powerUpType.symbol,
                    duration: powerUpType.duration,
                    pulse: 0
                });
            }
        }

        function activatePowerUp(powerUp) {
            playSound(800, 0.2, 'square');
            createParticles(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, powerUp.color, 15);

            switch (powerUp.type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth * 1.5;
                    activePowerUps.widePaddle = Date.now() + powerUp.duration;
                    break;

                case 'bigBall':
                    ball.radius = ball.originalRadius * 1.5;
                    activePowerUps.bigBall = Date.now() + powerUp.duration;
                    break;

                case 'extraLife':
                    lives++;
                    livesElement.textContent = lives;
                    break;

                case 'multiball':
                    for (let i = 0; i < 2; i++) {
                        activePowerUps.multiball.push({
                            x: ball.x + (Math.random() - 0.5) * 100,
                            y: ball.y + (Math.random() - 0.5) * 100,
                            radius: ball.radius,
                            dx: (Math.random() - 0.5) * ball.speed * 2,
                            dy: Math.random() > 0.5 ? ball.speed : -ball.speed,
                            trail: [],
                            stuckCounter: 0
                        });
                    }
                    break;

                case 'laser':
                    canShootLaser = true;
                    activePowerUps.laser = Date.now() + powerUp.duration;
                    break;

                case 'fireBall':
                    ball.fireBall = true;
                    activePowerUps.fireBall = Date.now() + powerUp.duration;
                    break;
            }
            updatePowerUpDisplay();
        }

        function updateCombo() {
            const now = Date.now();
            if (now - lastHitTime > 2000) {
                combo = 0;
            }
            combo++;
            lastHitTime = now;

            if (combo > maxCombo) {
                maxCombo = combo;
            }

            comboElement.textContent = combo;

            // Show combo display for high combos
            if (combo >= 5) {
                comboDisplayElement.textContent = `${combo}x COMBO!`;
                comboDisplayElement.style.display = 'block';
                comboDisplayElement.style.color = combo >= 10 ? '#ff4757' : '#ffd700';

                setTimeout(() => {
                    comboDisplayElement.style.display = 'none';
                }, 1500);
            }
        }

        function updatePowerUpDisplay() {
            let status = '';
            const now = Date.now();

            if (activePowerUps.widePaddle > now) {
                const remaining = Math.ceil((activePowerUps.widePaddle - now) / 1000);
                status += `Wide: ${remaining}s `;
            }
            if (activePowerUps.bigBall > now) {
                const remaining = Math.ceil((activePowerUps.bigBall - now) / 1000);
                status += `Big: ${remaining}s `;
            }
            if (activePowerUps.laser > now) {
                const remaining = Math.ceil((activePowerUps.laser - now) / 1000);
                status += `Laser: ${remaining}s `;
            }
            if (activePowerUps.fireBall > now) {
                const remaining = Math.ceil((activePowerUps.fireBall - now) / 1000);
                status += `Fire: ${remaining}s `;
            }
            if (activePowerUps.multiball.length > 0) {
                status += `Multi `;
            }
            powerUpStatusElement.textContent = status;
        }

        function updatePowerUps() {
            // Update power-up positions and effects
            powerUps.forEach((powerUp, index) => {
                powerUp.y += powerUp.dy;
                powerUp.pulse += 0.1;

                // Check collision with paddle
                if (powerUp.y + powerUp.height > paddle.y &&
                    powerUp.x + powerUp.width > paddle.x &&
                    powerUp.x < paddle.x + paddle.width) {
                    activatePowerUp(powerUp);
                    powerUps.splice(index, 1);
                }

                // Remove if off screen
                if (powerUp.y > canvas.height) {
                    powerUps.splice(index, 1);
                }
            });

            // Check power-up expiration
            const now = Date.now();

            if (activePowerUps.widePaddle > 0 && activePowerUps.widePaddle < now) {
                paddle.width = paddle.originalWidth;
                activePowerUps.widePaddle = 0;
            }

            if (activePowerUps.bigBall > 0 && activePowerUps.bigBall < now) {
                ball.radius = ball.originalRadius;
                activePowerUps.bigBall = 0;
            }

            if (activePowerUps.laser > 0 && activePowerUps.laser < now) {
                canShootLaser = false;
                activePowerUps.laser = 0;
            }

            if (activePowerUps.fireBall > 0 && activePowerUps.fireBall < now) {
                ball.fireBall = false;
                activePowerUps.fireBall = 0;
            }

            updatePowerUpDisplay();
        }

        function updateTrails() {
            // Update ball trail
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 10) ball.trail.shift();

            // Update multiball trails
            activePowerUps.multiball.forEach(extraBall => {
                extraBall.trail.push({ x: extraBall.x, y: extraBall.y });
                if (extraBall.trail.length > 8) extraBall.trail.shift();
            });

            // Update paddle trail
            paddle.trail.push({ x: paddle.x + paddle.width/2, y: paddle.y });
            if (paddle.trail.length > 5) paddle.trail.shift();
        }

        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.life -= particle.decay;
                particle.dy += 0.1; // Gravity

                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            explosions.forEach((explosion, index) => {
                explosion.radius += 2;
                explosion.life -= explosion.decay;

                if (explosion.life <= 0 || explosion.radius >= explosion.maxRadius) {
                    explosions.splice(index, 1);
                }
            });
        }

        function updateLasers() {
            if (laserCooldown > 0) laserCooldown--;

            lasers.forEach((laser, laserIndex) => {
                laser.y += laser.dy;

                // Remove lasers that go off screen
                if (laser.y < 0) {
                    lasers.splice(laserIndex, 1);
                    return;
                }

                // Check brick collisions
                bricks.forEach((brick, brickIndex) => {
                    if (brick.visible && brick.type !== 'unbreakable' && !brick.animating &&
                        laser.x < brick.x + brick.width &&
                        laser.x + laser.width > brick.x &&
                        laser.y < brick.y + brick.height &&
                        laser.y + laser.height > brick.y) {

                        // Remove laser
                        lasers.splice(laserIndex, 1);

                        // Damage brick
                        hitBrick(brick);
                    }
                });
            });
        }

        function hitBrick(brick) {
            if (brick.type === 'unbreakable' || brick.animating) return;

            updateCombo();

            if (brick.type === 'explosive') {
                // Explosive brick destroys nearby bricks
                createExplosion(brick.x + brick.width/2, brick.y + brick.height/2);
                playSound(300, 0.3, 'square', 0.15);

                bricks.forEach(nearbyBrick => {
                    const dx = nearbyBrick.x + nearbyBrick.width/2 - (brick.x + brick.width/2);
                    const dy = nearbyBrick.y + nearbyBrick.height/2 - (brick.y + brick.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 80 && nearbyBrick.visible && nearbyBrick.type !== 'unbreakable' && !nearbyBrick.animating) {
                        nearbyBrick.visible = false;
                        score += nearbyBrick.points + (combo * 5);
                        createParticles(nearbyBrick.x + nearbyBrick.width/2,
                                      nearbyBrick.y + nearbyBrick.height/2,
                                      nearbyBrick.color, 8);
                    }
                });

                brick.visible = false;
                score += brick.points + (combo * 5);
            } else {
                brick.hits--;

                if (brick.hits <= 0) {
                    brick.visible = false;
                    score += brick.points + (combo * 5);
                    createPowerUp(brick.x + brick.width/2, brick.y + brick.height/2);
                    createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 12);
                    playSound(600 + (brick.points * 5), 0.15);
                } else {
                    playSound(500, 0.1);
                    createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 5);
                }
            }

            scoreElement.textContent = score;
        }

        function drawTrails() {
            // Draw ball trail
            ball.trail.forEach((point, index) => {
                const alpha = index / ball.trail.length;
                ctx.globalAlpha = alpha * 0.5;
                ctx.beginPath();
                ctx.arc(point.x, point.y, ball.radius * alpha, 0, Math.PI * 2);
                ctx.fillStyle = ball.fireBall ? '#ff4757' : '#fff';
                ctx.fill();
            });

            // Draw multiball trails
            activePowerUps.multiball.forEach(extraBall => {
                extraBall.trail.forEach((point, index) => {
                    const alpha = index / extraBall.trail.length;
                    ctx.globalAlpha = alpha * 0.3;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, extraBall.radius * alpha, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff9ff3';
                    ctx.fill();
                });
            });

            ctx.globalAlpha = 1;
        }

        function drawParticles() {
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });

            explosions.forEach(explosion => {
                ctx.globalAlpha = explosion.life * 0.3;
                ctx.strokeStyle = '#ff4757';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();
            });

            ctx.globalAlpha = 1;
        }

        function drawLasers() {
            ctx.fillStyle = '#00d2d3';
            ctx.shadowColor = '#00d2d3';
            ctx.shadowBlur = 10;

            lasers.forEach(laser => {
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
            });

            ctx.shadowBlur = 0;
        }

        function drawPaddle() {
            // Draw paddle trail
            paddle.trail.forEach((point, index) => {
                const alpha = (index + 1) / paddle.trail.length;
                ctx.globalAlpha = alpha * 0.3;
                ctx.fillStyle = paddle.color;
                ctx.fillRect(point.x - paddle.width/2, paddle.y, paddle.width * alpha, paddle.height);
            });

            ctx.globalAlpha = 1;

            // Draw main paddle with gradient
            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(1, '#ccc');

            ctx.fillStyle = gradient;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

            // Add border
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        function drawBall() {
            // Draw ball trail first
            drawTrails();

            // Draw main ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);

            if (ball.fireBall) {
                const fireGradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
                fireGradient.addColorStop(0, '#fff');
                fireGradient.addColorStop(0.5, '#ff4757');
                fireGradient.addColorStop(1, '#ff3742');
                ctx.fillStyle = fireGradient;
                ctx.shadowColor = '#ff4757';
                ctx.shadowBlur = 15;
            } else {
                const ballGradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
                ballGradient.addColorStop(0, '#fff');
                ballGradient.addColorStop(1, '#ddd');
                ctx.fillStyle = ballGradient;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 5;
            }

            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw multiball balls
            activePowerUps.multiball.forEach(extraBall => {
                ctx.beginPath();
                ctx.arc(extraBall.x, extraBall.y, extraBall.radius, 0, Math.PI * 2);

                const multiGradient = ctx.createRadialGradient(extraBall.x, extraBall.y, 0, extraBall.x, extraBall.y, extraBall.radius);
                multiGradient.addColorStop(0, '#fff');
                multiGradient.addColorStop(1, '#ff9ff3');
                ctx.fillStyle = multiGradient;
                ctx.shadowColor = '#ff9ff3';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function drawBricks() {
            bricks.forEach(brick => {
                if (!brick.visible) return;

                // Create brick gradient
                const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
                gradient.addColorStop(0, brick.color);
                gradient.addColorStop(1, adjustBrightness(brick.color, -20));

                ctx.fillStyle = gradient;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

                // Add border
                ctx.strokeStyle = adjustBrightness(brick.color, -30);
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                // Show damage for multi-hit bricks
                if (brick.maxHits > 1 && brick.hits < brick.maxHits) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    const damageWidth = brick.width * (1 - brick.hits / brick.maxHits);
                    ctx.fillRect(brick.x, brick.y, damageWidth, brick.height);
                }

                // Add special effects for certain brick types
                if (brick.type === 'explosive') {
                    ctx.fillStyle = '#ff4757';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üí•', brick.x + brick.width/2, brick.y + brick.height/2 + 4);
                }
            });
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                const pulseSize = 1 + Math.sin(powerUp.pulse) * 0.1;

                ctx.save();
                ctx.translate(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2);
                ctx.scale(pulseSize, pulseSize);

                // Draw power-up background
                ctx.fillStyle = powerUp.color;
                ctx.fillRect(-powerUp.width/2, -powerUp.height/2, powerUp.width, powerUp.height);

                // Draw power-up symbol
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerUp.symbol, 0, 4);

                ctx.restore();
            });
        }

        function adjustBrightness(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }

        // FIXED: Ball collision detection with stuck ball prevention
        function updateBall() {
            const prevX = ball.x;
            const prevY = ball.y;

            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collisions
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
                ball.dx = -ball.dx;
                ball.x = ball.x - ball.radius < 0 ? ball.radius : canvas.width - ball.radius;
                playSound(400, 0.1);
            }

            if (ball.y - ball.radius < 0) {
                ball.dy = -ball.dy;
                ball.y = ball.radius;
                playSound(400, 0.1);
            }

            // FIXED: Anti-stuck mechanism
            if (Math.abs(ball.x - prevX) < 0.1 && Math.abs(ball.y - prevY) < 0.1) {
                ball.stuckCounter++;
                if (ball.stuckCounter > 120) { // 2 seconds at 60fps
                    // Randomize ball direction to unstick it
                    ball.dx = (Math.random() - 0.5) * ball.speed * 2;
                    ball.dy = Math.random() > 0.5 ? ball.speed : -ball.speed;
                    ball.stuckCounter = 0;
                    playSound(800, 0.2);
                }
            } else {
                ball.stuckCounter = 0;
            }

            // Paddle collision
            if (ball.y + ball.radius > paddle.y &&
                ball.x + ball.radius > paddle.x &&
                ball.x - ball.radius < paddle.x + paddle.width &&
                ball.dy > 0) {

                ball.dy = -Math.abs(ball.dy);

                // Add spin based on where ball hits paddle
                const hitPos = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
                ball.dx += hitPos * 2;

                // Limit ball speed
                const maxSpeed = ball.speed * 1.5;
                const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                if (currentSpeed > maxSpeed) {
                    ball.dx = (ball.dx / currentSpeed) * maxSpeed;
                    ball.dy = (ball.dy / currentSpeed) * maxSpeed;
                }

                playSound(300, 0.1);
                createParticles(ball.x, paddle.y, '#fff', 5);
            }

            // Brick collisions
            bricks.forEach(brick => {
                if (!brick.visible || brick.animating) return;

                if (ball.x + ball.radius > brick.x &&
                    ball.x - ball.radius < brick.x + brick.width &&
                    ball.y + ball.radius > brick.y &&
                    ball.y - ball.radius < brick.y + brick.height) {

                    // Determine collision side
                    const overlapLeft = (ball.x + ball.radius) - brick.x;
                    const overlapRight = (brick.x + brick.width) - (ball.x - ball.radius);
                    const overlapTop = (ball.y + ball.radius) - brick.y;
                    const overlapBottom = (brick.y + brick.height) - (ball.y - ball.radius);

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                        ball.dx = -ball.dx;
                    } else {
                        ball.dy = -ball.dy;
                    }

                    // Fire ball destroys without bouncing back
                    if (!ball.fireBall && brick.type !== 'unbreakable') {
                        // Normal collision response
                    }

                    hitBrick(brick);
                }
            });

            // Check if ball is out of bounds (life lost)
            if (ball.y > canvas.height + 50) {
                lives--;
                livesElement.textContent = lives;
                playSound(200, 0.5);

                if (lives <= 0) {
                    gameOver();
                } else {
                    resetBall();
                }
            }
        }

        // FIXED: Multiball collision with paddle
        function updateMultiball() {
            activePowerUps.multiball.forEach((extraBall, index) => {
                const prevX = extraBall.x;
                const prevY = extraBall.y;

                extraBall.x += extraBall.dx;
                extraBall.y += extraBall.dy;

                // Wall collisions
                if (extraBall.x - extraBall.radius < 0 || extraBall.x + extraBall.radius > canvas.width) {
                    extraBall.dx = -extraBall.dx;
                    extraBall.x = extraBall.x - extraBall.radius < 0 ? extraBall.radius : canvas.width - extraBall.radius;
                }

                if (extraBall.y - extraBall.radius < 0) {
                    extraBall.dy = -extraBall.dy;
                    extraBall.y = extraBall.radius;
                }

                // Anti-stuck mechanism for multiball
                if (Math.abs(extraBall.x - prevX) < 0.1 && Math.abs(extraBall.y - prevY) < 0.1) {
                    extraBall.stuckCounter++;
                    if (extraBall.stuckCounter > 120) {
                        extraBall.dx = (Math.random() - 0.5) * ball.speed * 2;
                        extraBall.dy = Math.random() > 0.5 ? ball.speed : -ball.speed;
                        extraBall.stuckCounter = 0;
                    }
                } else {
                    extraBall.stuckCounter = 0;
                }

                // FIXED: Paddle collision for multiball
                if (extraBall.y + extraBall.radius > paddle.y &&
                    extraBall.x + extraBall.radius > paddle.x &&
                    extraBall.x - extraBall.radius < paddle.x + paddle.width &&
                    extraBall.dy > 0) {

                    extraBall.dy = -Math.abs(extraBall.dy);

                    // Add spin based on where ball hits paddle
                    const hitPos = (extraBall.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
                    extraBall.dx += hitPos * 2;

                    playSound(300, 0.1);
                    createParticles(extraBall.x, paddle.y, '#ff9ff3', 3);
                }

                // Brick collisions
                bricks.forEach(brick => {
                    if (!brick.visible || brick.animating) return;

                    if (extraBall.x + extraBall.radius > brick.x &&
                        extraBall.x - extraBall.radius < brick.x + brick.width &&
                        extraBall.y + extraBall.radius > brick.y &&
                        extraBall.y - extraBall.radius < brick.y + brick.height) {

                        // Determine collision side
                        const overlapLeft = (extraBall.x + extraBall.radius) - brick.x;
                        const overlapRight = (brick.x + brick.width) - (extraBall.x - extraBall.radius);
                        const overlapTop = (extraBall.y + extraBall.radius) - brick.y;
                        const overlapBottom = (brick.y + brick.height) - (extraBall.y - extraBall.radius);

                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                            extraBall.dx = -extraBall.dx;
                        } else {
                            extraBall.dy = -extraBall.dy;
                        }

                        hitBrick(brick);
                    }
                });

                // Remove multiball if out of bounds
                if (extraBall.y > canvas.height + 50) {
                    activePowerUps.multiball.splice(index, 1);
                }
            });
        }

        function updatePaddle() {
            // Desktop controls
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                paddle.x -= paddle.speed;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                paddle.x += paddle.speed;
            }

            // Mobile controls
            if (touchControls.left) {
                paddle.x -= paddle.speed;
            }
            if (touchControls.right) {
                paddle.x += paddle.speed;
            }

            // Keep paddle within bounds
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
            ball.dy = -ball.speed;
            ball.stuckCounter = 0;
            ball.trail = [];
        }

        function checkWaveComplete() {
            const visibleBricks = bricks.filter(brick => brick.visible && brick.type !== 'unbreakable').length;
            if (visibleBricks === 0 && animatingBricks.length === 0) {
                wave++;
                waveElement.textContent = wave;
                combo = 0; // Reset combo for new wave

                // Clear any remaining multiballs
                activePowerUps.multiball = [];

                // Start wave transition
                startWaveTransition();
            }
        }

        function gameOver() {
            gameRunning = false;
            finalScoreElement.textContent = score;
            finalWaveElement.textContent = wave;
            maxComboElement.textContent = maxCombo;

            if (score > bestScore) {
                bestScore = score;
                bestScoreElement.textContent = bestScore;
            }
            gameOverBestScoreElement.textContent = bestScore;

            gameOverDiv.style.display = 'block';
            playSound(150, 1.0);
        }

        function restartGame() {
            gameRunning = true;
            gamePaused = false;
            waveTransitioning = false;
            score = 0;
            lives = 3;
            wave = 1;
            combo = 0;
            maxCombo = 0;

            // Reset UI
            scoreElement.textContent = score;
            livesElement.textContent = lives;
            comboElement.textContent = combo;
            waveElement.textContent = wave;

            // Reset game objects
            resetBall();
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = paddle.originalWidth;
            ball.radius = ball.originalRadius;
            ball.fireBall = false;

            // Reset power-ups
            powerUps = [];
            activePowerUps = {
                widePaddle: 0,
                bigBall: 0,
                extraLife: false,
                multiball: [],
                laser: 0,
                fireBall: 0
            };
            pausedPowerUpTimes = {
                widePaddle: 0,
                bigBall: 0,
                laser: 0,
                fireBall: 0
            };
            canShootLaser = false;
            lasers = [];

            // Reset particles
            particles = [];
            explosions = [];

            // Hide overlays
            gameOverDiv.style.display = 'none';
            pauseOverlay.style.display = 'none';

            // Generate initial wave colors and create bricks
            generateWaveColors();
            updateCanvasBackground();
            createBricks();
        }

        function gameLoop() {
            if (!gameRunning || gamePaused || waveTransitioning) {
                if (waveTransitioning || animatingBricks.length > 0) {
                    // Continue animating bricks during transition
                    animateBricksIn();

                    // Clear canvas and draw
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBricks();
                }
                requestAnimationFrame(gameLoop);
                return;
            }

            // Update game objects
            updatePaddle();
            updateBall();
            updateMultiball();
            updatePowerUps();
            updateLasers();
            updateTrails();
            updateParticles();
            animateBricksIn();

            // Check win condition
            checkWaveComplete();

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw everything
            drawBricks();
            drawPaddle();
            drawBall();
            drawPowerUps();
            drawLasers();
            drawParticles();

            requestAnimationFrame(gameLoop);
        }

        // Initialize audio context on first user interaction
        document.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Start the game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>