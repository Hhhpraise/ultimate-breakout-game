<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Ultimate Breakout Game - Fixed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            width: 100%;
            max-width: 820px;
            height: 100vh;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e);
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
            flex: 1;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        .ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }

        .controls {
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.3;
        }

        .mobile-controls {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-top: 10px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .control-group {
            display: flex;
            gap: 20px;
        }

        .laser-button {
            background: linear-gradient(45deg, #00d2d3, #0099cc);
            font-size: 20px;
        }

        .laser-button.active {
            background: linear-gradient(45deg, #00ffff, #00d2d3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            animation: laserGlow 1s ease-in-out infinite alternate;
        }

        @keyframes laserGlow {
            from { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
            to { box-shadow: 0 0 30px rgba(0, 255, 255, 0.9); }
        }

        .pause-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            font-size: 16px;
        }

        .sound-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            font-size: 20px;
        }

        .sound-button.muted {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
            width: 80%;
            max-width: 400px;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .btn:hover, .btn:active {
            transform: scale(1.05);
        }

        .wave-indicator {
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 8px;
        }

        .power-up-indicator {
            font-size: 12px;
            color: #00ff88;
            margin-bottom: 5px;
            min-height: 18px;
        }

        .live-stats {
            margin-top: 8px;
            font-size: 10px;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-item {
            margin: 2px 5px;
            color: #00ff88;
            font-weight: bold;
        }

        .stat-item.highlight {
            color: #ffd700;
        }

        .combo-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            color: white;
            z-index: 999;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
        }

        .pause-content {
            text-align: center;
            padding: 20px;
        }

        .pause-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .pause-subtitle {
            font-size: 18px;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .pause-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .resume-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .resume-btn:hover, .resume-btn:active {
            transform: scale(1.05);
        }

        .pause-sound-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        .pause-sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .wave-transition {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            color: white;
            text-align: center;
        }

        .wave-transition h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .wave-transition p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .wave-progress {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .wave-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d2d3, #ffd700);
            width: 0%;
            transition: width 0.1s ease;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            text-align: center;
        }

        .start-screen h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .start-screen p {
            margin: 10px 0;
            max-width: 600px;
            line-height: 1.6;
        }

        .best-score {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 50px;
            margin: 20px 0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ff88;
        }

        .start-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
        }

        .start-sound-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        .start-sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .footer {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .footer a {
            color: #00d2d3;
            text-decoration: none;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
        }

        .footer a:hover {
            color: #ff6b6b;
            transform: translateY(-2px);
        }

        .footer a i {
            font-size: 1.2rem;
        }

        .sound-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s;
            z-index: 200;
        }

        .sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .sound-toggle:active {
            transform: scale(0.95);
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .game-container {
                padding: 5px;
                border-radius: 0;
                height: 100vh;
            }

            .mobile-controls {
                display: flex;
            }

            .ui {
                font-size: 14px;
            }

            .wave-indicator {
                font-size: 12px;
            }

            .power-up-indicator {
                font-size: 10px;
            }

            .live-stats {
                font-size: 9px;
                padding: 6px;
            }

            .combo-indicator {
                font-size: 16px;
                top: 10px;
                right: 10px;
            }

            .pause-overlay {
                font-size: 28px;
            }

            .pause-title {
                font-size: 36px;
            }

            .pause-subtitle {
                font-size: 16px;
            }

            .wave-transition h2 {
                font-size: 2rem;
            }

            .wave-transition p {
                font-size: 1rem;
            }

            .wave-progress {
                width: 250px;
            }

            .start-screen h1 {
                font-size: 1.8rem;
            }

            .start-screen p {
                font-size: 0.9rem;
            }

            .best-score {
                font-size: 1.2rem;
                padding: 10px 20px;
            }

            .footer {
                flex-direction: column;
                gap: 15px;
                margin-top: 15px;
            }

            .btn {
                padding: 12px 24px;
                font-size: 18px;
            }

            .sound-toggle {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }

            .start-sound-toggle {
                width: 55px;
                height: 55px;
                font-size: 22px;
            }
        }

        @media (max-height: 600px) {
            .live-stats {
                padding: 4px;
                font-size: 8px;
            }

            .controls {
                font-size: 10px;
            }
        }

        /* New best score notification */
        .new-best-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #00ff88, #00d2d3);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.3);
            z-index: 3000;
            animation: newBestPulse 2s ease-in-out;
            pointer-events: none;
        }

        @keyframes newBestPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* Blue glow for laser power-up */
        .laser-glow {
            animation: laserPulse 1s ease-in-out infinite alternate;
        }

        @keyframes laserPulse {
            from { box-shadow: 0 0 15px rgba(0, 210, 211, 0.7); }
            to { box-shadow: 0 0 25px rgba(0, 210, 211, 1); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <button class="sound-toggle" id="soundToggle">🔊</button>

        <div class="start-screen" id="startScreen">
            <h1>ULTIMATE BREAKOUT </h1>
            <p>Destroy all bricks without losing your balls! Collect power-ups for special abilities.</p>

            <div class="best-score">Best Score: <span id="bestScore">0</span></div>

            <div class="start-controls">
                <button class="start-sound-toggle" id="startSoundToggle">🔊</button>
                <button class="btn" id="startBtn">START GAME</button>
            </div>

            <div class="footer">
                <a href="https://hhhpraise.github.io/portfolio/" target="_blank">
                    <i>👨‍💻</i> My Portfolio
                </a>
                <a href="mailto:hhhpraise33@gmail.com">
                    <i>✉️</i> Send Suggestions
                </a>
            </div>
        </div>

        <div class="wave-transition" id="waveTransition">
            <h2 id="waveTransitionTitle">Wave 1</h2>
            <p id="waveTransitionText">Get Ready!</p>
            <div class="wave-progress">
                <div class="wave-progress-bar" id="waveProgressBar"></div>
            </div>
        </div>

        <div class="wave-indicator">Wave: <span id="wave">1</span></div>
        <div class="power-up-indicator" id="powerUpStatus"></div>
        <div class="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Combo: <span id="combo">0</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>

        <div class="controls" id="desktopControls">
            Use ← → arrow keys or A/D to move • SPACE to shoot laser • P to pause
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-group">
                <button class="control-button" id="leftBtn">←</button>
                <button class="control-button" id="rightBtn">→</button>
            </div>
            <div class="control-group">
                <button class="control-button laser-button" id="laserBtn">⚡</button>
                <button class="control-button pause-button" id="pauseBtn">⏸</button>
            </div>
        </div>

        <div class="live-stats" id="liveStats">
            <div class="stat-item">Bricks: <span id="bricksRemaining">0</span>/<span id="totalBricks">0</span></div>
            <div class="stat-item">Time: <span id="timeSurvived">0:00</span></div>
            <div class="stat-item highlight">Wave Progress: <span id="waveProgress">0%</span></div>
        </div>

        <div class="combo-indicator" id="comboDisplay" style="display: none;"></div>

        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-content">
                <div class="pause-title">PAUSED</div>
                <div class="pause-subtitle">Game is paused</div>
                <div class="pause-controls">
                    <button class="pause-sound-toggle" id="pauseSoundToggle">🔊</button>
                    <button class="resume-btn" id="resumeBtn">RESUME GAME</button>
                </div>
            </div>
        </div>

        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Wave Reached: <span id="finalWave">1</span></p>
            <p>Max Combo: <span id="maxCombo">0</span></p>
            <p>Best Score: <span id="gameOverBestScore">0</span></p>
           <!-- To this: -->
            <button class="btn" id="restartBtn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        // Prevent double-tap zoom globally
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Prevent context menu on long press
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Color Theory Algorithms
        class ColorTheory {
            static hexToHsl(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return [h * 360, s * 100, l * 100];
            }

            static hslToHex(h, s, l) {
                h = h % 360;
                s = s / 100;
                l = l / 100;

                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;
                let r = 0, g = 0, b = 0;

                if (0 <= h && h < 60) {
                    r = c; g = x; b = 0;
                } else if (60 <= h && h < 120) {
                    r = x; g = c; b = 0;
                } else if (120 <= h && h < 180) {
                    r = 0; g = c; b = x;
                } else if (180 <= h && h < 240) {
                    r = 0; g = x; b = c;
                } else if (240 <= h && h < 300) {
                    r = x; g = 0; b = c;
                } else if (300 <= h && h < 360) {
                    r = c; g = 0; b = x;
                }

                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);

                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            static complementary(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    baseColor,
                    this.hslToHex((h + 180) % 360, s, l),
                    this.hslToHex(h, Math.max(20, s - 20), Math.min(80, l + 10)),
                    this.hslToHex((h + 180) % 360, Math.max(20, s - 20), Math.min(80, l + 10))
                ];
            }

            static analogous(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    this.hslToHex((h - 30 + 360) % 360, s, l),
                    baseColor,
                    this.hslToHex((h + 30) % 360, s, l),
                    this.hslToHex((h + 60) % 360, s, l)
                ];
            }

            static triadic(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    baseColor,
                    this.hslToHex((h + 120) % 360, s, l),
                    this.hslToHex((h + 240) % 360, s, l),
                    this.hslToHex(h, Math.max(30, s - 20), Math.min(85, l + 15))
                ];
            }

            static monochromatic(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    this.hslToHex(h, s, Math.min(90, l + 30)),
                    this.hslToHex(h, s, Math.min(80, l + 15)),
                    baseColor,
                    this.hslToHex(h, s, Math.max(20, l - 15))
                ];
            }
        }

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         ('ontouchstart' in window) ||
                         (navigator.maxTouchPoints > 0);

        // Best score management
        function loadBestScore() {
            try {
                const saved = parseInt(localStorage.getItem('ultimateBreakoutBestScore')) || 0;
                return saved;
            } catch (e) {
                return 0;
            }
        }

        function saveBestScore(score) {
            try {
                localStorage.setItem('ultimateBreakoutBestScore', score.toString());
            } catch (e) {
                // Silent fail if localStorage is not available
            }
        }

        function checkAndUpdateBestScore(currentScore) {
            if (currentScore > bestScore) {
                bestScore = currentScore;
                saveBestScore(bestScore);
                bestScoreElement.textContent = bestScore;
                gameOverBestScoreElement.textContent = bestScore;
                showNewBestNotification();
                return true;
            }
            return false;
        }

        function showNewBestNotification() {
            const notification = document.createElement('div');
            notification.className = 'new-best-notification';
            notification.textContent = '🎉 NEW BEST SCORE! 🎉';
            document.body.appendChild(notification);

            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }

        // Sound management
        let soundEnabled = true;
        const soundToggle = document.getElementById('soundToggle');
        const startSoundToggle = document.getElementById('startSoundToggle');
        const pauseSoundToggle = document.getElementById('pauseSoundToggle');

        function updateSoundToggle() {
            const icon = soundEnabled ? '🔊' : '🔇';
            soundToggle.textContent = icon;
            startSoundToggle.textContent = icon;
            pauseSoundToggle.textContent = icon;

            soundToggle.classList.toggle('muted', !soundEnabled);
            startSoundToggle.classList.toggle('muted', !soundEnabled);
            pauseSoundToggle.classList.toggle('muted', !soundEnabled);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            updateSoundToggle();
        }

        soundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            toggleSound();
        });

        startSoundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            toggleSound();
        });

        pauseSoundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleSound();
        });

        updateSoundToggle();

        // Canvas setup with responsive sizing
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerRect = container.getBoundingClientRect();

            if (isMobile) {
                canvas.width = Math.min(containerRect.width - 16, 800);
                canvas.height = Math.min(containerRect.height - 220, 500);
            } else {
                canvas.width = 800;
                canvas.height = 600;
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI elements
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const comboElement = document.getElementById('combo');
        const waveElement = document.getElementById('wave');
        const powerUpStatusElement = document.getElementById('powerUpStatus');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const finalWaveElement = document.getElementById('finalWave');
        const maxComboElement = document.getElementById('maxCombo');
        const gameOverBestScoreElement = document.getElementById('gameOverBestScore');
        const comboDisplayElement = document.getElementById('comboDisplay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const bestScoreElement = document.getElementById('bestScore');
        const waveTransition = document.getElementById('waveTransition');
        const waveTransitionTitle = document.getElementById('waveTransitionTitle');
        const waveTransitionText = document.getElementById('waveTransitionText');
        const waveProgressBar = document.getElementById('waveProgressBar');
        const restartBtn = document.getElementById('restartBtn');

        // Live stats elements
        const bricksRemainingElement = document.getElementById('bricksRemaining');
        const totalBricksElement = document.getElementById('totalBricks');
        const timeSurvivedElement = document.getElementById('timeSurvived');
        const waveProgressElement = document.getElementById('waveProgress');

        // Load best score
        let bestScore = loadBestScore();
        bestScoreElement.textContent = bestScore;

        // Show/hide controls based on device
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'flex';
            document.getElementById('desktopControls').style.display = 'none';
        }

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let waveTransitioning = false;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let combo = 0;
        let maxCombo = 0;
        let lastHitTime = 0;
        let currentWaveColors = ['#ff6b6b', '#4ecdc4', '#ffd700', '#c0c0c0'];
        let gameStartTime = 0;
        let totalBricksInWave = 0;
        let gameLoopId = null; // Track animation frame ID

        // Particles system
        let particles = [];
        let explosions = [];

        // Sound effects using Web Audio API
        let audioContext;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            // Fallback for browsers without Web Audio API
            audioContext = null;
        }

        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;

                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Silent fail for audio context issues
            }
        }

        // Paddle
        const paddle = {
            x: 0,
            y: 0,
            width: 120,
            height: 15,
            speed: 8,
            originalWidth: 120,
            color: '#fff',
            trail: [],
            glowing: false,
            laserGlow: false
        };

        // Ball
        const ball = {
            x: 0,
            y: 0,
            radius: 8,
            dx: 4,
            dy: -4,
            speed: 4,
            originalRadius: 8,
            trail: [],
            fireBall: false,
            stuckCounter: 0
        };

        // Initialize positions based on canvas size
        function initializePositions() {
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.y = canvas.height - 30;
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
        }

        initializePositions();

        // Lasers
        let lasers = [];
        let canShootLaser = false;
        let laserCooldown = 0;

        // Power-ups with proper pause handling
        let powerUps = [];
        let activePowerUps = {
            widePaddle: 0,
            bigBall: 0,
            extraLife: false,
            multiball: [],
            laser: 0,
            fireBall: 0
        };

        // Store remaining time when paused - FIXED
        let pausedPowerUpTimes = {
            widePaddle: 0,
            bigBall: 0,
            laser: 0,
            fireBall: 0
        };

        const powerUpTypes = [
            { type: 'widePaddle', color: '#ff6b6b', symbol: '=', duration: 15000 },
            { type: 'bigBall', color: '#4ecdc4', symbol: 'O', duration: 12000 },
            { type: 'extraLife', color: '#ffd700', symbol: '+', duration: 0 },
            { type: 'multiball', color: '#ff9ff3', symbol: '*', duration: 0 },
            { type: 'laser', color: '#00d2d3', symbol: '⚡', duration: 20000 },
            { type: 'fireBall', color: '#ff4757', symbol: '🔥', duration: 15000 }
        ];

        // Bricks
        let bricks = [];
        let animatingBricks = [];
        const brickRows = isMobile ? 5 : 6;
        const brickCols = isMobile ? 8 : 10;
        let brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;

        function calculateBrickDimensions() {
            brickWidth = (canvas.width - 70) / brickCols;
            brickHeight = isMobile ? 18 : 20;
            brickPadding = 5;
            brickOffsetTop = 60;
            brickOffsetLeft = 35;
        }

        calculateBrickDimensions();

        // Brick types with dynamic colors
        function getBrickTypes() {
            return {
                normal: { color: currentWaveColors[0], hits: 1, points: 10 },
                strong: { color: currentWaveColors[1], hits: 2, points: 25 },
                metal: { color: currentWaveColors[2], hits: 3, points: 50 },
                explosive: { color: '#ff4757', hits: 1, points: 75 },
                unbreakable: { color: '#2f3542', hits: -1, points: 0 }
            };
        }

        // Input handling
        const keys = {};
        let touchControls = {
            left: false,
            right: false
        };

        // Desktop controls
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                shootLaser();
            }
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Mobile controls
        if (isMobile) {
            // Touch controls for movement
            let touchStartX = 0;
            let touchCurrentX = 0;
            let isTouching = false;

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchCurrentX = touch.clientX;
                isTouching = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isTouching) {
                    const touch = e.touches[0];
                    touchCurrentX = touch.clientX;

                    const deltaX = touchCurrentX - touchStartX;
                    const sensitivity = 2;
                    paddle.x += deltaX * sensitivity;

                    // Keep paddle within bounds
                    paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

                    touchStartX = touchCurrentX;
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouching = false;
            });

            // Button controls
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const laserBtn = document.getElementById('laserBtn');
            const pauseBtn = document.getElementById('pauseBtn');

            // Movement buttons
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.left = true;
            });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls.left = false;
            });

            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.right = true;
            });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls.right = false;
            });

            // Laser button
            laserBtn.addEventListener('click', (e) => {
                e.preventDefault();
                shootLaser();
            });

            // Pause button
            pauseBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                togglePause();
            });
        }

        function updateLiveStats() {
            // Update time survived
            if (gameRunning && !gamePaused && !waveTransitioning) {
                const currentTime = Date.now();
                const timeElapsed = Math.floor((currentTime - gameStartTime) / 1000);
                const minutes = Math.floor(timeElapsed / 60);
                const seconds = timeElapsed % 60;
                timeSurvivedElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Update bricks remaining
            const remainingBricks = bricks.filter(brick => brick.visible && brick.type !== 'unbreakable').length;
            bricksRemainingElement.textContent = remainingBricks;
            totalBricksElement.textContent = totalBricksInWave;

            // Update wave progress
            const progress = totalBricksInWave > 0 ? Math.round((1 - remainingBricks / totalBricksInWave) * 100) : 0;
            waveProgressElement.textContent = `${progress}%`;
        }

        function updateLaserButtonGlow() {
            const laserBtn = document.getElementById('laserBtn');
            if (laserBtn) {
                if (canShootLaser) {
                    laserBtn.classList.add('active');
                } else {
                    laserBtn.classList.remove('active');
                }
            }
        }

        // FIXED: Generate truly random wave colors
        function generateWaveColors() {
            // Random base hue
            const baseHue = Math.random() * 360;
            // Random saturation between 60-90%
            const saturation = 60 + Math.random() * 30;
            // Random lightness between 40-70%
            const lightness = 40 + Math.random() * 30;

            const baseColor = ColorTheory.hslToHex(baseHue, saturation, lightness);

            // Randomly choose a color scheme
            const schemes = ['complementary', 'analogous', 'triadic', 'monochromatic'];
            const randomScheme = schemes[Math.floor(Math.random() * schemes.length)];

            switch (randomScheme) {
                case 'complementary':
                    currentWaveColors = ColorTheory.complementary(baseColor);
                    break;
                case 'analogous':
                    currentWaveColors = ColorTheory.analogous(baseColor);
                    break;
                case 'triadic':
                    currentWaveColors = ColorTheory.triadic(baseColor);
                    break;
                case 'monochromatic':
                    currentWaveColors = ColorTheory.monochromatic(baseColor);
                    break;
            }
        }

        function updateCanvasBackground() {
            // Update the canvas background gradient based on wave colors
            const canvasStyle = canvas.style;
            canvasStyle.background = `linear-gradient(45deg, ${currentWaveColors[0]}15, ${currentWaveColors[1]}15)`;
        }

        // FIXED: Proper power-up pause/resume handling
        function pausePowerUps() {
            const now = Date.now();
            if (activePowerUps.widePaddle > now) {
                pausedPowerUpTimes.widePaddle = activePowerUps.widePaddle - now;
                activePowerUps.widePaddle = 0;
            }
            if (activePowerUps.bigBall > now) {
                pausedPowerUpTimes.bigBall = activePowerUps.bigBall - now;
                activePowerUps.bigBall = 0;
            }
            if (activePowerUps.laser > now) {
                pausedPowerUpTimes.laser = activePowerUps.laser - now;
                activePowerUps.laser = 0;
            }
            if (activePowerUps.fireBall > now) {
                pausedPowerUpTimes.fireBall = activePowerUps.fireBall - now;
                activePowerUps.fireBall = 0;
            }
        }

        function resumePowerUps() {
            const now = Date.now();
            if (pausedPowerUpTimes.widePaddle > 0) {
                activePowerUps.widePaddle = now + pausedPowerUpTimes.widePaddle;
                pausedPowerUpTimes.widePaddle = 0;
            }
            if (pausedPowerUpTimes.bigBall > 0) {
                activePowerUps.bigBall = now + pausedPowerUpTimes.bigBall;
                pausedPowerUpTimes.bigBall = 0;
            }
            if (pausedPowerUpTimes.laser > 0) {
                activePowerUps.laser = now + pausedPowerUpTimes.laser;
                pausedPowerUpTimes.laser = 0;
            }
            if (pausedPowerUpTimes.fireBall > 0) {
                activePowerUps.fireBall = now + pausedPowerUpTimes.fireBall;
                pausedPowerUpTimes.fireBall = 0;
            }
        }

        // FIXED: Toggle pause function
        function togglePause() {
            if (!gameRunning || waveTransitioning) return;

            gamePaused = !gamePaused;
            pauseOverlay.style.display = gamePaused ? 'flex' : 'none';

            if (gamePaused) {
                pausePowerUps();
                // Stop the game loop
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
            } else {
                resumePowerUps();
                // Resume audio context if needed
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                // Restart the game loop
                gameLoop();
            }
        }

        // Pause overlay click/touch handlers
        pauseOverlay.addEventListener('click', (e) => {
            if (gamePaused && e.target === pauseOverlay) {
                togglePause();
            }
        });

        pauseOverlay.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gamePaused && e.target === pauseOverlay) {
                togglePause();
            }
        });

        // Resume button
        resumeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gamePaused) {
                togglePause();
            }
        });

        resumeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (gamePaused) {
                togglePause();
            }
        });

        function startGame() {
            gameRunning = true;
            gameStartTime = Date.now();
            startScreen.style.display = 'none';
            restartGame();
        }

        // Start button event listener
        startBtn.addEventListener('click', startGame);

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 60,
                life: 1,
                decay: 0.05
            });

            // Create shockwave particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * 6,
                    dy: Math.sin(angle) * 6,
                    color: '#ff4757',
                    life: 1,
                    decay: 0.03,
                    size: 3
                });
            }
        }

        function shootLaser() {
            if (canShootLaser && laserCooldown <= 0 && gameRunning && !gamePaused && !waveTransitioning) {
                lasers.push({
                    x: paddle.x + paddle.width / 2 - 2,
                    y: paddle.y,
                    width: 4,
                    height: 20,
                    dy: -15
                });
                laserCooldown = 15; // Cooldown frames
                playSound(1000, 0.1, 'square', 0.05);
            }
        }

        // FIXED: Generate truly random brick patterns
        function generateBrickPattern() {
            const patterns = [
                'solid', 'checkerboard', 'pyramid', 'diamond', 'cross', 'waves', 'random', 'spiral', 'alternating'
            ];
            // Truly random pattern selection
            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const brickPositions = [];

            switch (pattern) {
                case 'solid':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            brickPositions.push({row: r, col: c});
                        }
                    }
                    break;

                case 'checkerboard':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if ((r + c) % 2 === 0) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'pyramid':
                    for (let r = 0; r < brickRows; r++) {
                        const bricksInRow = Math.max(1, brickCols - r * 2);
                        const startCol = Math.floor((brickCols - bricksInRow) / 2);
                        for (let i = 0; i < bricksInRow; i++) {
                            brickPositions.push({row: r, col: startCol + i});
                        }
                    }
                    break;

                case 'diamond':
                    const centerRow = Math.floor(brickRows / 2);
                    for (let r = 0; r < brickRows; r++) {
                        const distFromCenter = Math.abs(r - centerRow);
                        const bricksInRow = Math.max(1, brickCols - distFromCenter * 2);
                        const startCol = Math.floor((brickCols - bricksInRow) / 2);
                        for (let i = 0; i < bricksInRow; i++) {
                            brickPositions.push({row: r, col: startCol + i});
                        }
                    }
                    break;

                case 'cross':
                    const centerCol = Math.floor(brickCols / 2);
                    const centerRowCross = Math.floor(brickRows / 2);
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (r === centerRowCross || c === centerCol) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'waves':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (Math.sin(c * 0.8 + r * 0.5) > -0.3) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'spiral':
                    const centerRowSpiral = Math.floor(brickRows / 2);
                    const centerColSpiral = Math.floor(brickCols / 2);
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            const angle = Math.atan2(r - centerRowSpiral, c - centerColSpiral);
                            const distance = Math.sqrt(Math.pow(r - centerRowSpiral, 2) + Math.pow(c - centerColSpiral, 2));
                            if (Math.sin(angle * 3 + distance * 0.5) > 0) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'alternating':
                    for (let r = 0; r < brickRows; r++) {
                        const offset = r % 2;
                        for (let c = offset; c < brickCols; c += 2) {
                            brickPositions.push({row: r, col: c});
                        }
                    }
                    break;

                case 'random':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (Math.random() > 0.25) { // 75% chance for brick
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;
            }

            return brickPositions;
        }

        // WAVE TRANSITION ANIMATION
        function startWaveTransition() {
            waveTransitioning = true;
            waveTransition.style.display = 'flex';
            waveTransitionTitle.textContent = `Wave ${wave}`;

            const messages = [
                'Get Ready!',
                'Prepare for Battle!',
                'Incoming Bricks!',
                'Power Up!',
                'Stay Alert!',
                'Here We Go!',
                'Brace Yourself!'
            ];
            waveTransitionText.textContent = messages[Math.floor(Math.random() * messages.length)];

            // Generate new wave colors
            generateWaveColors();
            updateCanvasBackground();

            // Animate progress bar
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 2;
                waveProgressBar.style.width = progress + '%';

                if (progress >= 100) {
                    clearInterval(progressInterval);
                    setTimeout(() => {
                        waveTransition.style.display = 'none';
                        waveTransitioning = false;
                        createBricks(); // Create bricks after transition
                    }, 500);
                }
            }, 30);
        }

        function createBricks() {
            bricks = [];
            animatingBricks = [];
            calculateBrickDimensions();
            const brickTypes = getBrickTypes();
            const positions = generateBrickPattern();

            // Count total destructible bricks for stats
            totalBricksInWave = positions.length;

            positions.forEach((pos, index) => {
                let type = 'normal';

                // Add variety based on wave and position
                if (wave >= 2 && Math.random() < 0.25) {
                    type = 'strong';
                }
                if (wave >= 3 && Math.random() < 0.15) {
                    type = 'metal';
                }
                if (wave >= 4 && Math.random() < 0.1) {
                    type = 'explosive';
                }
                if (wave >= 5 && Math.random() < 0.05) {
                    type = 'unbreakable';
                    totalBricksInWave--; // Don't count unbreakable bricks
                }

                const brickType = brickTypes[type];
                const targetX = pos.col * (brickWidth + brickPadding) + brickOffsetLeft;
                const targetY = pos.row * (brickHeight + brickPadding) + brickOffsetTop;

                // Create brick with animation properties
                const brick = {
                    x: targetX,
                    y: -brickHeight, // Start above screen
                    targetX: targetX,
                    targetY: targetY,
                    width: brickWidth,
                    height: brickHeight,
                    type: type,
                    color: brickType.color,
                    maxHits: brickType.hits,
                    hits: brickType.hits,
                    points: brickType.points,
                    visible: true,
                    animating: true,
                    animationDelay: index * 50, // Stagger the animation
                    animationProgress: 0
                };

                bricks.push(brick);
                animatingBricks.push(brick);
            });
        }

        function animateBricksIn() {
            animatingBricks.forEach((brick, index) => {
                if (brick.animationDelay > 0) {
                    brick.animationDelay -= 16; // Roughly 60fps
                    return;
                }

                brick.animationProgress += 0.05;
                if (brick.animationProgress >= 1) {
                    brick.animationProgress = 1;
                    brick.animating = false;
                    brick.y = brick.targetY;
                } else {
                    // Easing function for smooth animation
                    const easeOut = 1 - Math.pow(1 - brick.animationProgress, 3);
                    brick.y = -brick.height + (brick.targetY + brick.height) * easeOut;
                }
            });

            // Remove finished animations
            animatingBricks = animatingBricks.filter(brick => brick.animating);
        }

        function createPowerUp(x, y) {
            if (Math.random() < 0.25) { // 25% chance for power-up
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUps.push({
                    x: x,
                    y: y,
                    width: 20,
                    height: 20,
                    dy: 2,
                    type: powerUpType.type,
                    color: powerUpType.color,
                    symbol: powerUpType.symbol,
                    duration: powerUpType.duration,
                    pulse: 0
                });
            }
        }

        function activatePowerUp(powerUp) {
            playSound(800, 0.2, 'square');
            createParticles(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, powerUp.color, 15);

            switch (powerUp.type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth * 1.5;
                    activePowerUps.widePaddle = Date.now() + powerUp.duration;
                    break;

                case 'bigBall':
                    ball.radius = ball.originalRadius * 1.5;
                    activePowerUps.bigBall = Date.now() + powerUp.duration;
                    break;

                case 'extraLife':
                    lives++;
                    livesElement.textContent = lives;
                    break;

                case 'multiball':
                    for (let i = 0; i < 2; i++) {
                        activePowerUps.multiball.push({
                            x: ball.x + (Math.random() - 0.5) * 100,
                            y: ball.y + (Math.random() - 0.5) * 100,
                            radius: ball.radius,
                            dx: (Math.random() - 0.5) * ball.speed * 2,
                            dy: Math.random() > 0.5 * ball.speed * 2,
                            dy: -Math.abs(ball.speed),
                            speed: ball.speed,
                            trail: [],
                            fireBall: ball.fireBall,
                            stuckCounter: 0
                        });
                    }
                    break;

                case 'laser':
                    canShootLaser = true;
                    activePowerUps.laser = Date.now() + powerUp.duration;
                    paddle.laserGlow = true;
                    break;

                case 'fireBall':
                    ball.fireBall = true;
                    activePowerUps.fireBall = Date.now() + powerUp.duration;
                    break;
            }
        }

        function updatePowerUps() {
            if (!gamePaused && !waveTransitioning) {
                const now = Date.now();

                // Update timed power-ups
                if (activePowerUps.widePaddle > 0 && now > activePowerUps.widePaddle) {
                    paddle.width = paddle.originalWidth;
                    activePowerUps.widePaddle = 0;
                }

                if (activePowerUps.bigBall > 0 && now > activePowerUps.bigBall) {
                    ball.radius = ball.originalRadius;
                    // Reset multiball radii too
                    activePowerUps.multiball.forEach(mb => {
                        mb.radius = ball.originalRadius;
                    });
                    activePowerUps.bigBall = 0;
                }

                if (activePowerUps.laser > 0 && now > activePowerUps.laser) {
                    canShootLaser = false;
                    activePowerUps.laser = 0;
                    paddle.laserGlow = false;
                }

                if (activePowerUps.fireBall > 0 && now > activePowerUps.fireBall) {
                    ball.fireBall = false;
                    // Reset multiball fire state too
                    activePowerUps.multiball.forEach(mb => {
                        mb.fireBall = false;
                    });
                    activePowerUps.fireBall = 0;
                }

                // Update power-up display
                let statusText = '';
                if (activePowerUps.widePaddle > now) {
                    const remaining = Math.ceil((activePowerUps.widePaddle - now) / 1000);
                    statusText += `Wide Paddle: ${remaining}s `;
                }
                if (activePowerUps.bigBall > now) {
                    const remaining = Math.ceil((activePowerUps.bigBall - now) / 1000);
                    statusText += `Big Ball: ${remaining}s `;
                }
                if (activePowerUps.laser > now) {
                    const remaining = Math.ceil((activePowerUps.laser - now) / 1000);
                    statusText += `Laser: ${remaining}s `;
                }
                if (activePowerUps.fireBall > now) {
                    const remaining = Math.ceil((activePowerUps.fireBall - now) / 1000);
                    statusText += `Fire Ball: ${remaining}s `;
                }
                if (activePowerUps.multiball.length > 0) {
                    statusText += `Multiball: ${activePowerUps.multiball.length} extra `;
                }

                powerUpStatusElement.textContent = statusText;
                updateLaserButtonGlow();
            }

            // Update falling power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (!gamePaused && !waveTransitioning) {
                    powerUp.y += powerUp.dy;
                    powerUp.pulse += 0.1;
                }

                // Check collision with paddle
                if (powerUp.x < paddle.x + paddle.width &&
                    powerUp.x + powerUp.width > paddle.x &&
                    powerUp.y < paddle.y + paddle.height &&
                    powerUp.y + powerUp.height > paddle.y) {
                    activatePowerUp(powerUp);
                    powerUps.splice(i, 1);
                } else if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
        }

        function hitBrick(brick, ball) {
            if (!brick.visible) return false;

            // Check collision
            if (ball.x - ball.radius < brick.x + brick.width &&
                ball.x + ball.radius > brick.x &&
                ball.y - ball.radius < brick.y + brick.height &&
                ball.y + ball.radius > brick.y) {

                // Handle different brick types
                if (brick.type === 'unbreakable') {
                    playSound(150, 0.1);
                    return true; // Collision but no destruction
                }

                // Damage brick
                if (brick.type !== 'explosive' || !ball.fireBall) {
                    brick.hits--;
                }

                if (brick.hits <= 0 || ball.fireBall) {
                    brick.visible = false;
                    score += brick.points;

                    // Update combo
                    const now = Date.now();
                    if (now - lastHitTime < 1000) {
                        combo++;
                        if (combo > maxCombo) maxCombo = combo;
                    } else {
                        combo = 1;
                    }
                    lastHitTime = now;

                    // Show combo display
                    if (combo > 3) {
                        comboDisplayElement.textContent = `${combo}x COMBO!`;
                        comboDisplayElement.style.display = 'block';
                        setTimeout(() => {
                            comboDisplayElement.style.display = 'none';
                        }, 1000);
                    }

                    // Update UI
                    scoreElement.textContent = score;
                    comboElement.textContent = combo;

                    // Sound effects
                    if (brick.type === 'explosive') {
                        playSound(100, 0.3);
                        createExplosion(brick.x + brick.width/2, brick.y + brick.height/2);
                        // Damage nearby bricks
                        bricks.forEach(nearbyBrick => {
                            if (nearbyBrick.visible && nearbyBrick !== brick) {
                                const distance = Math.sqrt(
                                    Math.pow(nearbyBrick.x + nearbyBrick.width/2 - (brick.x + brick.width/2), 2) +
                                    Math.pow(nearbyBrick.y + nearbyBrick.height/2 - (brick.y + brick.height/2), 2)
                                );
                                if (distance < 80 && nearbyBrick.type !== 'unbreakable') {
                                    nearbyBrick.hits--;
                                    if (nearbyBrick.hits <= 0) {
                                        nearbyBrick.visible = false;
                                        score += nearbyBrick.points;
                                        createParticles(nearbyBrick.x + nearbyBrick.width/2,
                                                      nearbyBrick.y + nearbyBrick.height/2,
                                                      nearbyBrick.color, 8);
                                    }
                                }
                            }
                        });
                    } else {
                        playSound(200 + Math.random() * 100, 0.1);
                    }

                    createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color);
                    createPowerUp(brick.x + brick.width/2, brick.y + brick.height/2);
                } else {
                    // Brick damaged but not destroyed
                    playSound(300, 0.1);
                    createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 5);
                }

                return true;
            }
            return false;
        }

        function ballPaddleCollision(ball) {
            if (ball.x > paddle.x && ball.x < paddle.x + paddle.width &&
                ball.y + ball.radius > paddle.y && ball.y - ball.radius < paddle.y + paddle.height) {

                // Calculate bounce angle based on where ball hits paddle
                const hitPos = (ball.x - paddle.x) / paddle.width;
                const bounceAngle = (hitPos - 0.5) * Math.PI / 3; // Max 60 degrees

                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx = Math.sin(bounceAngle) * speed;
                ball.dy = -Math.abs(Math.cos(bounceAngle) * speed);

                // Ensure minimum upward velocity
                if (ball.dy > -2) ball.dy = -2;

                ball.y = paddle.y - ball.radius;
                ball.stuckCounter = 0;

                playSound(400, 0.1);
                paddle.glowing = true;
                setTimeout(() => paddle.glowing = false, 100);

                // Add trail effect
                ball.trail.push({x: ball.x, y: ball.y, life: 1});
            }
        }

        function updateBall() {
            if (gamePaused || waveTransitioning) return;

            // Main ball
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Ball trail
            ball.trail = ball.trail.filter(t => {
                t.life -= 0.05;
                return t.life > 0;
            });
            ball.trail.push({x: ball.x, y: ball.y, life: 1});
            if (ball.trail.length > 10) ball.trail.shift();

            // Wall collisions
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
                ball.dx = -ball.dx;
                ball.x = ball.x - ball.radius < 0 ? ball.radius : canvas.width - ball.radius;
                playSound(300, 0.1);
            }

            if (ball.y - ball.radius < 0) {
                ball.dy = -ball.dy;
                ball.y = ball.radius;
                playSound(300, 0.1);
            }

            // Paddle collision
            ballPaddleCollision(ball);

            // Brick collisions
            let hitAnyBrick = false;
            for (let brick of bricks) {
                if (hitBrick(brick, ball)) {
                    if (brick.type !== 'unbreakable' || !ball.fireBall) {
                        ball.dy = -ball.dy;
                    }
                    hitAnyBrick = true;
                    break;
                }
            }

            // Anti-stuck mechanism
            if (Math.abs(ball.dy) < 1) {
                ball.stuckCounter++;
                if (ball.stuckCounter > 120) { // 2 seconds at 60fps
                    ball.dy = ball.dy > 0 ? 2 : -2;
                    ball.stuckCounter = 0;
                }
            } else {
                ball.stuckCounter = 0;
            }

            // Multiball update with FIXED paddle collision
            for (let i = activePowerUps.multiball.length - 1; i >= 0; i--) {
                const mb = activePowerUps.multiball[i];

                mb.x += mb.dx;
                mb.y += mb.dy;

                // Multiball trail
                mb.trail = mb.trail.filter(t => {
                    t.life -= 0.05;
                    return t.life > 0;
                });
                mb.trail.push({x: mb.x, y: mb.y, life: 1});
                if (mb.trail.length > 8) mb.trail.shift();

                // Wall collisions for multiball
                if (mb.x - mb.radius < 0 || mb.x + mb.radius > canvas.width) {
                    mb.dx = -mb.dx;
                    mb.x = mb.x - mb.radius < 0 ? mb.radius : canvas.width - mb.radius;
                    playSound(300, 0.1);
                }

                if (mb.y - mb.radius < 0) {
                    mb.dy = -mb.dy;
                    mb.y = mb.radius;
                    playSound(300, 0.1);
                }

                // FIXED: Multiball paddle collision
                ballPaddleCollision(mb);

                // Multiball brick collisions
                for (let brick of bricks) {
                    if (hitBrick(brick, mb)) {
                        if (brick.type !== 'unbreakable' || !mb.fireBall) {
                            mb.dy = -mb.dy;
                        }
                        break;
                    }
                }

                // Remove multiball if it falls off screen
                if (mb.y > canvas.height + 50) {
                    activePowerUps.multiball.splice(i, 1);
                }

                // Anti-stuck for multiball
                if (Math.abs(mb.dy) < 1) {
                    mb.stuckCounter++;
                    if (mb.stuckCounter > 120) {
                        mb.dy = mb.dy > 0 ? 2 : -2;
                        mb.stuckCounter = 0;
                    }
                } else {
                    mb.stuckCounter = 0;
                }
            }

            // Check if ball fell off screen
            if (ball.y > canvas.height + 50) {
                if (activePowerUps.multiball.length > 0) {
                    // Transfer multiball to main ball
                    const mb = activePowerUps.multiball.shift();
                    ball.x = mb.x;
                    ball.y = mb.y;
                    ball.dx = mb.dx;
                    ball.dy = mb.dy;
                    ball.fireBall = mb.fireBall;
                } else {
                    lives--;
                    livesElement.textContent = lives;

                    if (lives <= 0) {
                        gameOver();
                    } else {
                        resetBall();
                        playSound(150, 0.5);
                    }
                }
            }
        }

        function updateLasers() {
            if (gamePaused || waveTransitioning) return;

            // Update laser cooldown
            if (laserCooldown > 0) laserCooldown--;

            // Update lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.y += laser.dy;

                // Check brick collisions
                for (let brick of bricks) {
                    if (brick.visible &&
                        laser.x < brick.x + brick.width &&
                        laser.x + laser.width > brick.x &&
                        laser.y < brick.y + brick.height &&
                        laser.y + laser.height > brick.y) {

                        // Laser destroys brick regardless of type (except unbreakable)
                        if (brick.type !== 'unbreakable') {
                            brick.visible = false;
                            score += brick.points * 2; // Double points for laser hits
                            scoreElement.textContent = score;
                            createParticles(brick.x + brick.width/2, brick.y + brick.height/2, '#00d2d3');
                            playSound(800, 0.1);
                        }

                        lasers.splice(i, 1);
                        break;
                    }
                }

                // Remove laser if off screen
                if (laser.y < -laser.height) {
                    lasers.splice(i, 1);
                }
            }
        }

        function updateParticles() {
            if (gamePaused || waveTransitioning) return;

            // Update particles
            particles = particles.filter(particle => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.life -= particle.decay;
                particle.dx *= 0.99; // Slight damping
                particle.dy *= 0.99;
                return particle.life > 0;
            });

            // Update explosions
            explosions = explosions.filter(explosion => {
                explosion.radius += 2;
                explosion.life -= explosion.decay;
                return explosion.life > 0 && explosion.radius < explosion.maxRadius;
            });
        }

        function updatePaddle() {
            if (gamePaused || waveTransitioning) return;

            // Desktop controls
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                paddle.x -= paddle.speed;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                paddle.x += paddle.speed;
            }

            // Mobile touch controls
            if (touchControls.left) {
                paddle.x -= paddle.speed;
            }
            if (touchControls.right) {
                paddle.x += paddle.speed;
            }

            // Keep paddle within bounds
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

            // Paddle trail effect
            paddle.trail = paddle.trail.filter(t => {
                t.life -= 0.1;
                return t.life > 0;
            });
            if ((keys['ArrowLeft'] || keys['a'] || keys['A'] || touchControls.left ||
                 keys['ArrowRight'] || keys['d'] || keys['D'] || touchControls.right)) {
                paddle.trail.push({
                    x: paddle.x + paddle.width/2,
                    y: paddle.y + paddle.height/2,
                    life: 1
                });
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
            ball.dy = -ball.speed;
            ball.trail = [];
            ball.stuckCounter = 0;
        }

        function checkWaveComplete() {
            // Prevent multiple wave completions during transition
            if (waveTransitioning) return false;

            const remainingBricks = bricks.filter(brick =>
                brick.visible && brick.type !== 'unbreakable'
            ).length;

            if (remainingBricks === 0) {
                wave++;
                waveElement.textContent = wave;

                // Bonus points for wave completion
                const waveBonus = wave * 100;
                score += waveBonus;
                scoreElement.textContent = score;

                // Clear remaining power-ups and multiballs for next wave
                powerUps = [];
                activePowerUps.multiball = [];

                // Set wave transitioning flag immediately
                waveTransitioning = true;

                // Start next wave transition
                setTimeout(() => {
                    startWaveTransition();
                }, 1000);

                playSound(600, 0.5);

                return true;
            }
            return false;
        }

        function gameOver() {
            gameRunning = false;
            gamePaused = false;

            // Stop the game loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            // Check for new best score
            checkAndUpdateBestScore(score);

            finalScoreElement.textContent = score;
            finalWaveElement.textContent = wave;
            maxComboElement.textContent = maxCombo;
            gameOverBestScoreElement.textContent = bestScore;
            gameOverDiv.style.display = 'block';

            playSound(200, 1.0);
        }

        function restartGame() {
            // Reset game state
            score = 0;
            lives = 3;
            wave = 1;
            combo = 0;
            maxCombo = 0;
            gameStartTime = Date.now();
            gamePaused = false;
            waveTransitioning = false;
            gameRunning = true; // Add this line

            // Reset objects
            paddle.width = paddle.originalWidth;
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.trail = [];
            paddle.glowing = false;
            paddle.laserGlow = false;

            ball.radius = ball.originalRadius;
            ball.fireBall = false;
            resetBall();

            // Clear arrays
            lasers = [];
            powerUps = [];
            particles = [];
            explosions = [];
            bricks = [];
            animatingBricks = [];

            // Reset power-ups
            activePowerUps = {
                widePaddle: 0,
                bigBall: 0,
                extraLife: false,
                multiball: [],
                laser: 0,
                fireBall: 0
            };
            pausedPowerUpTimes = {
                widePaddle: 0,
                bigBall: 0,
                laser: 0,
                fireBall: 0
            };
            canShootLaser = false;
            laserCooldown = 0;

            // Update UI
            scoreElement.textContent = score;
            livesElement.textContent = lives;
            comboElement.textContent = combo;
            waveElement.textContent = wave;
            powerUpStatusElement.textContent = '';
            gameOverDiv.style.display = 'none'; // Hide game over screen
            pauseOverlay.style.display = 'none';
            comboDisplayElement.style.display = 'none';

            // Generate first wave colors and start
            generateWaveColors();
            updateCanvasBackground();
            startWaveTransition();

            // Start the game loop
            if (!gameLoopId) {
                gameLoop();
            }
        }

        function drawBrick(brick) {
            if (!brick.visible) return;

            ctx.save();

            // Shadow effect
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Brick color based on damage
            let alpha = 1;
            if (brick.maxHits > 1) {
                alpha = brick.hits / brick.maxHits;
            }

            ctx.fillStyle = brick.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

            // Special effects for brick types
            if (brick.type === 'metal') {
                ctx.strokeStyle = '#silver';
                ctx.lineWidth = 2;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            } else if (brick.type === 'explosive') {
                ctx.fillStyle = '#ff4757';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('💥', brick.x + brick.width/2, brick.y + brick.height/2 + 4);
            } else if (brick.type === 'unbreakable') {
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('⚡', brick.x + brick.width/2, brick.y + brick.height/2 + 3);
            }

            // Damage indicator
            if (brick.maxHits > 1 && brick.hits < brick.maxHits) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(brick.hits.toString(), brick.x + brick.width/2, brick.y + brick.height/2 + 3);
            }

            ctx.restore();
        }

        function draw() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f0f23');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw animated brick entrance
            animateBricksIn();

            // Draw bricks
            bricks.forEach(drawBrick);

            // Draw particles
            particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Draw explosions
            explosions.forEach(explosion => {
                ctx.save();
                ctx.globalAlpha = explosion.life;
                ctx.strokeStyle = '#ff4757';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });

            // Draw paddle trail
            paddle.trail.forEach((trail, index) => {
                ctx.save();
                ctx.globalAlpha = trail.life * 0.5;
                ctx.fillStyle = paddle.glowing ? '#ffd700' : (paddle.laserGlow ? '#00d2d3' : '#fff');
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Draw paddle with blue glow for laser power-up
            ctx.save();
            if (paddle.glowing) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
            } else if (paddle.laserGlow) {
                ctx.shadowColor = '#00d2d3';
                ctx.shadowBlur = 15;
            }
            ctx.fillStyle = paddle.glowing ? '#ffd700' : (paddle.laserGlow ? '#00d2d3' : paddle.color);
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.restore();

            // Draw ball trail
            ball.trail.forEach((trail, index) => {
                ctx.save();
                ctx.globalAlpha = trail.life * 0.6;
                ctx.fillStyle = ball.fireBall ? '#ff4757' : '#fff';
                const size = (trail.life * ball.radius) * 0.8;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Draw main ball
            ctx.save();
            if (ball.fireBall) {
                ctx.shadowColor = '#ff4757';
                ctx.shadowBlur = 15;
            }
            ctx.fillStyle = ball.fireBall ? '#ff4757' : '#fff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Draw multiball
            activePowerUps.multiball.forEach(mb => {
                // Draw trail
                mb.trail.forEach(trail => {
                    ctx.save();
                    ctx.globalAlpha = trail.life * 0.6;
                    ctx.fillStyle = mb.fireBall ? '#ff4757' : '#4ecdc4';
                    const size = (trail.life * mb.radius) * 0.8;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                // Draw ball
                ctx.save();
                if (mb.fireBall) {
                    ctx.shadowColor = '#ff4757';
                    ctx.shadowBlur = 15;
                }
                ctx.fillStyle = mb.fireBall ? '#ff4757' : '#4ecdc4';
                ctx.beginPath();
                ctx.arc(mb.x, mb.y, mb.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Draw lasers
            lasers.forEach(laser => {
                ctx.save();
                ctx.shadowColor = '#00d2d3';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#00d2d3';
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);

                // Laser glow effect
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(laser.x + 1, laser.y, laser.width - 2, laser.height);
                ctx.restore();
            });

            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.save();

                // Pulsing effect
                const pulse = Math.sin(powerUp.pulse) * 0.2 + 1;
                ctx.translate(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2);
                ctx.scale(pulse, pulse);
                ctx.translate(-powerUp.width/2, -powerUp.height/2);

                // Glow effect
                ctx.shadowColor = powerUp.color;
                ctx.shadowBlur = 15;

                ctx.fillStyle = powerUp.color;
                ctx.fillRect(0, 0, powerUp.width, powerUp.height);

                // Symbol
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 0;
                ctx.fillText(powerUp.symbol, powerUp.width/2, powerUp.height/2 + 4);

                ctx.restore();
            });
        }

        // FIXED: Proper game loop with pause handling
        function gameLoop() {
            if (!gameRunning) return;

            if (!gamePaused && !waveTransitioning) {
                updatePaddle();
                updateBall();
                updateLasers();
                updatePowerUps();
                updateParticles();
                checkWaveComplete();
                updateLiveStats();
            }

            draw();

            // FIXED: Always schedule next frame when game is running
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Initialize the game
        resizeCanvas();
        updateCanvasBackground();



    </script>
</body>
</html>