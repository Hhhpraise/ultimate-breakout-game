<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Ultimate Breakout Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            width: 100%;
            max-width: 820px;
            height: 100vh;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e);
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
            flex: 1;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        .ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }

        .controls {
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.3;
        }

        .mobile-controls {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-top: 10px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .control-group {
            display: flex;
            gap: 20px;
        }

        .laser-button {
            background: linear-gradient(45deg, #00d2d3, #0099cc);
            font-size: 20px;
        }

        .laser-button.active {
            background: linear-gradient(45deg, #00ffff, #00d2d3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            animation: laserGlow 1s ease-in-out infinite alternate;
        }

        @keyframes laserGlow {
            from { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
            to { box-shadow: 0 0 30px rgba(0, 255, 255, 0.9); }
        }

        .pause-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            font-size: 16px;
        }

        .sound-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            font-size: 20px;
        }

        .sound-button.muted {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
            width: 80%;
            max-width: 400px;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .btn:hover, .btn:active {
            transform: scale(1.05);
        }

        .wave-indicator {
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 8px;
        }

        .power-up-indicator {
            font-size: 12px;
            color: #00ff88;
            margin-bottom: 5px;
            min-height: 18px;
        }

        .live-stats {
            margin-top: 8px;
            font-size: 10px;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-item {
            margin: 2px 5px;
            color: #00ff88;
            font-weight: bold;
        }

        .stat-item.highlight {
            color: #ffd700;
        }

        .combo-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            color: white;
            z-index: 999;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
        }

        .pause-content {
            text-align: center;
            padding: 20px;
        }

        .pause-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .pause-subtitle {
            font-size: 18px;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .pause-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .resume-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            transition: transform 0.2s;
            touch-action: manipulation;
        }

        .resume-btn:hover, .resume-btn:active {
            transform: scale(1.05);
        }

        .pause-sound-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        .pause-sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .wave-transition {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            color: white;
            text-align: center;
        }

        .wave-transition h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .wave-transition p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .wave-progress {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .wave-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d2d3, #ffd700);
            width: 0%;
            transition: width 0.1s ease;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            text-align: center;
        }

        .start-screen h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .start-screen p {
            margin: 10px 0;
            max-width: 600px;
            line-height: 1.6;
        }

        .best-score {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 50px;
            margin: 20px 0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ff88;
        }

        .start-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
        }

        .start-sound-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s;
        }

        .start-sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .footer {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .footer a {
            color: #00d2d3;
            text-decoration: none;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s;
        }

        .footer a:hover {
            color: #ff6b6b;
            transform: translateY(-2px);
        }

        .footer a i {
            font-size: 1.2rem;
        }

        .sound-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.2s;
            z-index: 200;
        }

        .sound-toggle.muted {
            background: rgba(220, 53, 69, 0.3);
            border-color: rgba(220, 53, 69, 0.5);
        }

        .sound-toggle:active {
            transform: scale(0.95);
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .game-container {
                padding: 5px;
                border-radius: 0;
                height: 100vh;
            }

            .mobile-controls {
                display: flex;
            }

            .ui {
                font-size: 14px;
            }

            .wave-indicator {
                font-size: 12px;
            }

            .power-up-indicator {
                font-size: 10px;
            }

            .live-stats {
                font-size: 9px;
                padding: 6px;
            }

            .combo-indicator {
                font-size: 16px;
                top: 10px;
                right: 10px;
            }

            .pause-overlay {
                font-size: 28px;
            }

            .pause-title {
                font-size: 36px;
            }

            .pause-subtitle {
                font-size: 16px;
            }

            .wave-transition h2 {
                font-size: 2rem;
            }

            .wave-transition p {
                font-size: 1rem;
            }

            .wave-progress {
                width: 250px;
            }

            .start-screen h1 {
                font-size: 1.8rem;
            }

            .start-screen p {
                font-size: 0.9rem;
            }

            .best-score {
                font-size: 1.2rem;
                padding: 10px 20px;
            }

            .footer {
                flex-direction: column;
                gap: 15px;
                margin-top: 15px;
            }

            .btn {
                padding: 12px 24px;
                font-size: 18px;
            }

            .sound-toggle {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }

            .start-sound-toggle {
                width: 55px;
                height: 55px;
                font-size: 22px;
            }
        }

        @media (max-height: 600px) {
            .live-stats {
                padding: 4px;
                font-size: 8px;
            }

            .controls {
                font-size: 10px;
            }
        }

        /* Laser paddle glow effect */
        .paddle-glow {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        /* New best score notification */
        .new-best-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #00ff88, #00d2d3);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.3);
            z-index: 3000;
            animation: newBestPulse 2s ease-in-out;
            pointer-events: none;
        }

        @keyframes newBestPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <button class="sound-toggle" id="soundToggle">🔊</button>

        <div class="start-screen" id="startScreen">
            <h1>ULTIMATE BREAKOUT</h1>
            <p>Destroy all bricks without losing your balls! Collect power-ups for special abilities.</p>

            <div class="best-score">Best Score: <span id="bestScore">0</span></div>

            <div class="start-controls">
                <button class="start-sound-toggle" id="startSoundToggle">🔊</button>
                <button class="btn" id="startBtn">START GAME</button>
            </div>

            <div class="footer">
                <a href="https://hhhpraise.github.io/portfolio/" target="_blank">
                    <i>👨‍💻</i> My Portfolio
                </a>
                <a href="mailto:hhhpraise33@gmail.com">
                    <i>✉️</i> Send Suggestions
                </a>
            </div>
        </div>

        <div class="wave-transition" id="waveTransition">
            <h2 id="waveTransitionTitle">Wave 1</h2>
            <p id="waveTransitionText">Get Ready!</p>
            <div class="wave-progress">
                <div class="wave-progress-bar" id="waveProgressBar"></div>
            </div>
        </div>

        <div class="wave-indicator">Wave: <span id="wave">1</span></div>
        <div class="power-up-indicator" id="powerUpStatus"></div>
        <div class="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Combo: <span id="combo">0</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>

        <div class="controls" id="desktopControls">
            Use ← → arrow keys or A/D to move • SPACE to shoot laser • P to pause
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-group">
                <button class="control-button" id="leftBtn">←</button>
                <button class="control-button" id="rightBtn">→</button>
            </div>
            <div class="control-group">
                <button class="control-button laser-button" id="laserBtn">⚡</button>
                <button class="control-button pause-button" id="pauseBtn">⏸</button>
            </div>
        </div>

        <div class="live-stats" id="liveStats">
            <div class="stat-item">Bricks: <span id="bricksRemaining">0</span>/<span id="totalBricks">0</span></div>
            <div class="stat-item">Time: <span id="timeSurvived">0:00</span></div>
            <div class="stat-item highlight">Wave Progress: <span id="waveProgress">0%</span></div>
        </div>

        <div class="combo-indicator" id="comboDisplay" style="display: none;"></div>

        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-content">
                <div class="pause-title">PAUSED</div>
                <div class="pause-subtitle">Game is paused</div>
                <div class="pause-controls">
                    <button class="pause-sound-toggle" id="pauseSoundToggle">🔊</button>
                    <button class="resume-btn" id="resumeBtn">RESUME GAME</button>
                </div>
            </div>
        </div>

        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Wave Reached: <span id="finalWave">1</span></p>
            <p>Max Combo: <span id="maxCombo">0</span></p>
            <p>Best Score: <span id="gameOverBestScore">0</span></p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <canvas id="exportCanvas" style="display: none;"></canvas>

    <script>
        // Color Theory Algorithms
        class ColorTheory {
            static hexToHsl(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return [h * 360, s * 100, l * 100];
            }

            static hslToHex(h, s, l) {
                h = h % 360;
                s = s / 100;
                l = l / 100;

                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;
                let r = 0, g = 0, b = 0;

                if (0 <= h && h < 60) {
                    r = c; g = x; b = 0;
                } else if (60 <= h && h < 120) {
                    r = x; g = c; b = 0;
                } else if (120 <= h && h < 180) {
                    r = 0; g = c; b = x;
                } else if (180 <= h && h < 240) {
                    r = 0; g = x; b = c;
                } else if (240 <= h && h < 300) {
                    r = x; g = 0; b = c;
                } else if (300 <= h && h < 360) {
                    r = c; g = 0; b = x;
                }

                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);

                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            static complementary(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    baseColor,
                    this.hslToHex((h + 180) % 360, s, l),
                    this.hslToHex(h, Math.max(20, s - 20), Math.min(80, l + 10)),
                    this.hslToHex((h + 180) % 360, Math.max(20, s - 20), Math.min(80, l + 10))
                ];
            }

            static analogous(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    this.hslToHex((h - 30 + 360) % 360, s, l),
                    baseColor,
                    this.hslToHex((h + 30) % 360, s, l),
                    this.hslToHex((h + 60) % 360, s, l)
                ];
            }

            static triadic(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    baseColor,
                    this.hslToHex((h + 120) % 360, s, l),
                    this.hslToHex((h + 240) % 360, s, l),
                    this.hslToHex(h, Math.max(30, s - 20), Math.min(85, l + 15))
                ];
            }

            static monochromatic(baseColor) {
                const [h, s, l] = this.hexToHsl(baseColor);
                return [
                    this.hslToHex(h, s, Math.min(90, l + 30)),
                    this.hslToHex(h, s, Math.min(80, l + 15)),
                    baseColor,
                    this.hslToHex(h, s, Math.max(20, l - 15))
                ];
            }
        }

        // Device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         ('ontouchstart' in window) ||
                         (navigator.maxTouchPoints > 0);

        // Best score management
        function loadBestScore() {
            try {
                const saved = parseInt(localStorage.getItem('ultimateBreakoutBestScore')) || 0;
                return saved;
            } catch (e) {
                return 0;
            }
        }

        function saveBestScore(score) {
            try {
                localStorage.setItem('ultimateBreakoutBestScore', score.toString());
            } catch (e) {
                // Silent fail if localStorage is not available
            }
        }

        function checkAndUpdateBestScore(currentScore) {
            if (currentScore > bestScore) {
                bestScore = currentScore;
                saveBestScore(bestScore);
                bestScoreElement.textContent = bestScore;
                gameOverBestScoreElement.textContent = bestScore;
                showNewBestNotification();
                return true;
            }
            return false;
        }

        function showNewBestNotification() {
            const notification = document.createElement('div');
            notification.className = 'new-best-notification';
            notification.textContent = '🎉 NEW BEST SCORE! 🎉';
            document.body.appendChild(notification);

            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }

        // Sound management
        let soundEnabled = true;
        const soundToggle = document.getElementById('soundToggle');
        const startSoundToggle = document.getElementById('startSoundToggle');
        const pauseSoundToggle = document.getElementById('pauseSoundToggle');

        function updateSoundToggle() {
            const icon = soundEnabled ? '🔊' : '🔇';
            soundToggle.textContent = icon;
            startSoundToggle.textContent = icon;
            pauseSoundToggle.textContent = icon;

            soundToggle.classList.toggle('muted', !soundEnabled);
            startSoundToggle.classList.toggle('muted', !soundEnabled);
            pauseSoundToggle.classList.toggle('muted', !soundEnabled);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            updateSoundToggle();
        }

        soundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            toggleSound();
        });

        startSoundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            toggleSound();
        });

        pauseSoundToggle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleSound();
        });

        updateSoundToggle();

        // Canvas setup with responsive sizing
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerRect = container.getBoundingClientRect();

            if (isMobile) {
                canvas.width = Math.min(containerRect.width - 16, 800);
                canvas.height = Math.min(containerRect.height - 220, 500);
            } else {
                canvas.width = 800;
                canvas.height = 600;
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI elements
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const comboElement = document.getElementById('combo');
        const waveElement = document.getElementById('wave');
        const powerUpStatusElement = document.getElementById('powerUpStatus');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const finalWaveElement = document.getElementById('finalWave');
        const maxComboElement = document.getElementById('maxCombo');
        const gameOverBestScoreElement = document.getElementById('gameOverBestScore');
        const comboDisplayElement = document.getElementById('comboDisplay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const bestScoreElement = document.getElementById('bestScore');
        const waveTransition = document.getElementById('waveTransition');
        const waveTransitionTitle = document.getElementById('waveTransitionTitle');
        const waveTransitionText = document.getElementById('waveTransitionText');
        const waveProgressBar = document.getElementById('waveProgressBar');

        // Live stats elements
        const bricksRemainingElement = document.getElementById('bricksRemaining');
        const totalBricksElement = document.getElementById('totalBricks');
        const timeSurvivedElement = document.getElementById('timeSurvived');
        const waveProgressElement = document.getElementById('waveProgress');

        // Load best score
        let bestScore = loadBestScore();
        bestScoreElement.textContent = bestScore;

        // Show/hide controls based on device
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'flex';
            document.getElementById('desktopControls').style.display = 'none';
        }

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let waveTransitioning = false;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let combo = 0;
        let maxCombo = 0;
        let lastHitTime = 0;
        let currentWaveColors = ['#ff6b6b', '#4ecdc4', '#ffd700', '#c0c0c0'];
        let gameStartTime = 0;
        let totalBricksInWave = 0;

        // Particles system
        let particles = [];
        let explosions = [];

        // Sound effects using Web Audio API
        let audioContext;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            // Fallback for browsers without Web Audio API
            audioContext = null;
        }

        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = type;

                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Silent fail for audio context issues
            }
        }

        // Paddle
        const paddle = {
            x: 0,
            y: 0,
            width: 120,
            height: 15,
            speed: 8,
            originalWidth: 120,
            color: '#fff',
            trail: [],
            glowing: false
        };

        // Ball
        const ball = {
            x: 0,
            y: 0,
            radius: 8,
            dx: 4,
            dy: -4,
            speed: 4,
            originalRadius: 8,
            trail: [],
            fireBall: false,
            stuckCounter: 0
        };

        // Initialize positions based on canvas size
        function initializePositions() {
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.y = canvas.height - 30;
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
        }

        initializePositions();

        // Lasers
        let lasers = [];
        let canShootLaser = false;
        let laserCooldown = 0;

        // Power-ups with proper pause handling
        let powerUps = [];
        let activePowerUps = {
            widePaddle: 0,
            bigBall: 0,
            extraLife: false,
            multiball: [],
            laser: 0,
            fireBall: 0
        };

        // Store remaining time when paused - FIXED
        let pausedPowerUpTimes = {
            widePaddle: 0,
            bigBall: 0,
            laser: 0,
            fireBall: 0
        };

        const powerUpTypes = [
            { type: 'widePaddle', color: '#ff6b6b', symbol: '=', duration: 15000 },
            { type: 'bigBall', color: '#4ecdc4', symbol: 'O', duration: 12000 },
            { type: 'extraLife', color: '#ffd700', symbol: '+', duration: 0 },
            { type: 'multiball', color: '#ff9ff3', symbol: '*', duration: 0 },
            { type: 'laser', color: '#00d2d3', symbol: '⚡', duration: 20000 },
            { type: 'fireBall', color: '#ff4757', symbol: '🔥', duration: 15000 }
        ];

        // Bricks
        let bricks = [];
        let animatingBricks = [];
        const brickRows = isMobile ? 5 : 6;
        const brickCols = isMobile ? 8 : 10;
        let brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;

        function calculateBrickDimensions() {
            brickWidth = (canvas.width - 70) / brickCols;
            brickHeight = isMobile ? 18 : 20;
            brickPadding = 5;
            brickOffsetTop = 60;
            brickOffsetLeft = 35;
        }

        calculateBrickDimensions();

        // Brick types with dynamic colors
        function getBrickTypes() {
            return {
                normal: { color: currentWaveColors[0], hits: 1, points: 10 },
                strong: { color: currentWaveColors[1], hits: 2, points: 25 },
                metal: { color: currentWaveColors[2], hits: 3, points: 50 },
                explosive: { color: '#ff4757', hits: 1, points: 75 },
                unbreakable: { color: '#2f3542', hits: -1, points: 0 }
            };
        }

        // Input handling
        const keys = {};
        let touchControls = {
            left: false,
            right: false
        };

        // Prevent double-tap zoom and context menu on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Prevent context menu on long press
        document.addEventListener('contextmenu', (e) => {
            if (isMobile) {
                e.preventDefault();
            }
        });

        // Desktop controls
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                shootLaser();
            }
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Mobile controls
        if (isMobile) {
            // Touch controls for movement
            let touchStartX = 0;
            let touchCurrentX = 0;
            let isTouching = false;

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchCurrentX = touch.clientX;
                isTouching = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isTouching) {
                    const touch = e.touches[0];
                    touchCurrentX = touch.clientX;

                    const deltaX = touchCurrentX - touchStartX;
                    const sensitivity = 2;
                    paddle.x += deltaX * sensitivity;

                    // Keep paddle within bounds
                    paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

                    touchStartX = touchCurrentX;
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouching = false;
            });

            // Button controls
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const laserBtn = document.getElementById('laserBtn');
            const pauseBtn = document.getElementById('pauseBtn');

            // Movement buttons
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.left = true;
            });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls.left = false;
            });

            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.right = true;
            });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchControls.right = false;
            });

            // Laser button
            laserBtn.addEventListener('click', (e) => {
                e.preventDefault();
                shootLaser();
            });

            // Pause button
            pauseBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                togglePause();
            });
        }

        function updateLiveStats() {
            // Update time survived
            if (gameRunning && !gamePaused && !waveTransitioning) {
                const currentTime = Date.now();
                const timeElapsed = Math.floor((currentTime - gameStartTime) / 1000);
                const minutes = Math.floor(timeElapsed / 60);
                const seconds = timeElapsed % 60;
                timeSurvivedElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Update bricks remaining
            const remainingBricks = bricks.filter(brick => brick.visible && brick.type !== 'unbreakable').length;
            bricksRemainingElement.textContent = remainingBricks;
            totalBricksElement.textContent = totalBricksInWave;

            // Update wave progress
            const progress = totalBricksInWave > 0 ? Math.round((1 - remainingBricks / totalBricksInWave) * 100) : 0;
            waveProgressElement.textContent = `${progress}%`;
        }

        function updateLaserButtonGlow() {
            const laserBtn = document.getElementById('laserBtn');
            if (laserBtn) {
                if (canShootLaser) {
                    laserBtn.classList.add('active');
                } else {
                    laserBtn.classList.remove('active');
                }
            }
        }

        function generateWaveColors() {
            // Generate a random base color for each wave
            const baseHue = (wave * 137.5) % 360; // Golden angle for good distribution
            const baseColor = ColorTheory.hslToHex(baseHue, 70, 50);

            // Use different color schemes for variety
            const schemes = ['complementary', 'analogous', 'triadic', 'monochromatic'];
            const scheme = schemes[wave % schemes.length];

            switch (scheme) {
                case 'complementary':
                    currentWaveColors = ColorTheory.complementary(baseColor);
                    break;
                case 'analogous':
                    currentWaveColors = ColorTheory.analogous(baseColor);
                    break;
                case 'triadic':
                    currentWaveColors = ColorTheory.triadic(baseColor);
                    break;
                case 'monochromatic':
                    currentWaveColors = ColorTheory.monochromatic(baseColor);
                    break;
            }
        }

        function updateCanvasBackground() {
            // Update the canvas background gradient based on wave colors
            const canvasStyle = canvas.style;
            canvasStyle.background = `linear-gradient(45deg, ${currentWaveColors[0]}15, ${currentWaveColors[1]}15)`;
        }

        // FIXED: Proper power-up pause/resume handling
        function pausePowerUps() {
            const now = Date.now();
            if (activePowerUps.widePaddle > now) {
                pausedPowerUpTimes.widePaddle = activePowerUps.widePaddle - now;
                activePowerUps.widePaddle = 0; // Clear the active timer
            }
            if (activePowerUps.bigBall > now) {
                pausedPowerUpTimes.bigBall = activePowerUps.bigBall - now;
                activePowerUps.bigBall = 0;
            }
            if (activePowerUps.laser > now) {
                pausedPowerUpTimes.laser = activePowerUps.laser - now;
                activePowerUps.laser = 0;
            }
            if (activePowerUps.fireBall > now) {
                pausedPowerUpTimes.fireBall = activePowerUps.fireBall - now;
                activePowerUps.fireBall = 0;
            }
        }

        function resumePowerUps() {
            const now = Date.now();
            if (pausedPowerUpTimes.widePaddle > 0) {
                activePowerUps.widePaddle = now + pausedPowerUpTimes.widePaddle;
                pausedPowerUpTimes.widePaddle = 0;
            }
            if (pausedPowerUpTimes.bigBall > 0) {
                activePowerUps.bigBall = now + pausedPowerUpTimes.bigBall;
                pausedPowerUpTimes.bigBall = 0;
            }
            if (pausedPowerUpTimes.laser > 0) {
                activePowerUps.laser = now + pausedPowerUpTimes.laser;
                pausedPowerUpTimes.laser = 0;
            }
            if (pausedPowerUpTimes.fireBall > 0) {
                activePowerUps.fireBall = now + pausedPowerUpTimes.fireBall;
                pausedPowerUpTimes.fireBall = 0;
            }
        }

        function togglePause() {
            if (!gameRunning || waveTransitioning) return;

            gamePaused = !gamePaused;
            pauseOverlay.style.display = gamePaused ? 'flex' : 'none';

            if (gamePaused) {
                pausePowerUps();
            } else {
                resumePowerUps();
                // Resume audio context if needed
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
        }

        // Pause overlay click/touch handlers
        pauseOverlay.addEventListener('click', (e) => {
            if (gamePaused && e.target === pauseOverlay) {
                togglePause();
            }
        });

        pauseOverlay.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gamePaused && e.target === pauseOverlay) {
                togglePause();
            }
        });

        // Resume button
        resumeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gamePaused) {
                togglePause();
            }
        });

        resumeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (gamePaused) {
                togglePause();
            }
        });

        function startGame() {
            gameRunning = true;
            gameStartTime = Date.now();
            startScreen.style.display = 'none';
            restartGame();
        }

        // Start button event listener
        startBtn.addEventListener('click', startGame);

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: 60,
                life: 1,
                decay: 0.05
            });

            // Create shockwave particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * 6,
                    dy: Math.sin(angle) * 6,
                    color: '#ff4757',
                    life: 1,
                    decay: 0.03,
                    size: 3
                });
            }
        }

        function shootLaser() {
            if (canShootLaser && laserCooldown <= 0 && gameRunning && !gamePaused && !waveTransitioning) {
                lasers.push({
                    x: paddle.x + paddle.width / 2 - 2,
                    y: paddle.y,
                    width: 4,
                    height: 20,
                    dy: -15
                });
                laserCooldown = 15; // Cooldown frames
                playSound(1000, 0.1, 'square', 0.05);
            }
        }

        function generateBrickPattern() {
            // Create different brick patterns for variety
            const patterns = [
                'solid', 'checkerboard', 'pyramid', 'diamond', 'cross', 'waves', 'random'
            ];
            const pattern = patterns[wave % patterns.length];
            const brickPositions = [];

            switch (pattern) {
                case 'solid':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            brickPositions.push({row: r, col: c});
                        }
                    }
                    break;

                case 'checkerboard':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if ((r + c) % 2 === 0) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'pyramid':
                    for (let r = 0; r < brickRows; r++) {
                        const bricksInRow = Math.max(1, brickCols - r * 2);
                        const startCol = Math.floor((brickCols - bricksInRow) / 2);
                        for (let i = 0; i < bricksInRow; i++) {
                            brickPositions.push({row: r, col: startCol + i});
                        }
                    }
                    break;

                case 'diamond':
                    const centerRow = Math.floor(brickRows / 2);
                    for (let r = 0; r < brickRows; r++) {
                        const distFromCenter = Math.abs(r - centerRow);
                        const bricksInRow = Math.max(1, brickCols - distFromCenter * 2);
                        const startCol = Math.floor((brickCols - bricksInRow) / 2);
                        for (let i = 0; i < bricksInRow; i++) {
                            brickPositions.push({row: r, col: startCol + i});
                        }
                    }
                    break;

                case 'cross':
                    const centerCol = Math.floor(brickCols / 2);
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (r === centerRow || c === centerCol ||
                                Math.abs(r - centerRow) === Math.abs(c - centerCol)) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'waves':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (Math.sin(c * 0.8 + r * 0.5) > -0.3) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;

                case 'random':
                    for (let r = 0; r < brickRows; r++) {
                        for (let c = 0; c < brickCols; c++) {
                            if (Math.random() > 0.3) {
                                brickPositions.push({row: r, col: c});
                            }
                        }
                    }
                    break;
            }

            return brickPositions;
        }

        // WAVE TRANSITION ANIMATION
        function startWaveTransition() {
            waveTransitioning = true;
            waveTransition.style.display = 'flex';
            waveTransitionTitle.textContent = `Wave ${wave}`;

            const messages = [
                'Get Ready!',
                'Prepare for Battle!',
                'Incoming Bricks!',
                'Power Up!',
                'Stay Alert!',
                'Here We Go!',
                'Brace Yourself!'
            ];
            waveTransitionText.textContent = messages[Math.floor(Math.random() * messages.length)];

            // Generate new wave colors
            generateWaveColors();
            updateCanvasBackground();

            // Animate progress bar
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 2;
                waveProgressBar.style.width = progress + '%';

                if (progress >= 100) {
                    clearInterval(progressInterval);
                    setTimeout(() => {
                        waveTransition.style.display = 'none';
                        waveTransitioning = false;
                        createBricks(); // Create bricks after transition
                    }, 500);
                }
            }, 30);
        }

        function createBricks() {
            bricks = [];
            animatingBricks = [];
            calculateBrickDimensions();
            const brickTypes = getBrickTypes();
            const positions = generateBrickPattern();

            // Count total destructible bricks for stats
            totalBricksInWave = positions.length;

            positions.forEach((pos, index) => {
                let type = 'normal';

                // Add variety based on wave and position
                if (wave >= 2 && Math.random() < 0.25) {
                    type = 'strong';
                }
                if (wave >= 3 && Math.random() < 0.15) {
                    type = 'metal';
                }
                if (wave >= 4 && Math.random() < 0.1) {
                    type = 'explosive';
                }
                if (wave >= 5 && Math.random() < 0.05) {
                    type = 'unbreakable';
                    totalBricksInWave--; // Don't count unbreakable bricks
                }

                const brickType = brickTypes[type];
                const targetX = pos.col * (brickWidth + brickPadding) + brickOffsetLeft;
                const targetY = pos.row * (brickHeight + brickPadding) + brickOffsetTop;

                // Create brick with animation properties
                const brick = {
                    x: targetX,
                    y: -brickHeight, // Start above screen
                    targetX: targetX,
                    targetY: targetY,
                    width: brickWidth,
                    height: brickHeight,
                    type: type,
                    color: brickType.color,
                    maxHits: brickType.hits,
                    hits: brickType.hits,
                    points: brickType.points,
                    visible: true,
                    animating: true,
                    animationDelay: index * 50, // Stagger the animation
                    animationProgress: 0
                };

                bricks.push(brick);
                animatingBricks.push(brick);
            });
        }

        function animateBricksIn() {
            animatingBricks.forEach((brick, index) => {
                if (brick.animationDelay > 0) {
                    brick.animationDelay -= 16; // Roughly 60fps
                    return;
                }

                brick.animationProgress += 0.05;
                if (brick.animationProgress >= 1) {
                    brick.animationProgress = 1;
                    brick.animating = false;
                    brick.y = brick.targetY;
                } else {
                    // Easing function for smooth animation
                    const easeOut = 1 - Math.pow(1 - brick.animationProgress, 3);
                    brick.y = -brick.height + (brick.targetY + brick.height) * easeOut;
                }
            });

            // Remove finished animations
            animatingBricks = animatingBricks.filter(brick => brick.animating);
        }

        function createPowerUp(x, y) {
            if (Math.random() < 0.25) { // 25% chance for power-up
                const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUps.push({
                    x: x,
                    y: y,
                    width: 20,
                    height: 20,
                    dy: 2,
                    type: powerUpType.type,
                    color: powerUpType.color,
                    symbol: powerUpType.symbol,
                    duration: powerUpType.duration,
                    pulse: 0
                });
            }
        }

        function activatePowerUp(powerUp) {
            playSound(800, 0.2, 'square');
            createParticles(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, powerUp.color, 15);

            switch (powerUp.type) {
                case 'widePaddle':
                    paddle.width = paddle.originalWidth * 1.5;
                    activePowerUps.widePaddle = Date.now() + powerUp.duration;
                    break;

                case 'bigBall':
                    ball.radius = ball.originalRadius * 1.5;
                    activePowerUps.bigBall = Date.now() + powerUp.duration;
                    break;

                case 'extraLife':
                    lives++;
                    livesElement.textContent = lives;
                    break;

                case 'multiball':
                    for (let i = 0; i < 2; i++) {
                        activePowerUps.multiball.push({
                            x: ball.x + (Math.random() - 0.5) * 100,
                            y: ball.y + (Math.random() - 0.5) * 100,
                            radius: ball.radius,
                            dx: (Math.random() - 0.5) * ball.speed * 2,
                            dy: Math.random() > 0.5 ? ball.speed : -ball.speed,
                            trail: [],
                            stuckCounter: 0
                        });
                    }
                    break;

                case 'laser':
                    canShootLaser = true;
                    paddle.glowing = true;
                    activePowerUps.laser = Date.now() + powerUp.duration;
                    updateLaserButtonGlow();
                    break;

                case 'fireBall':
                    ball.fireBall = true;
                    activePowerUps.fireBall = Date.now() + powerUp.duration;
                    break;
            }
            updatePowerUpDisplay();
        }

        function updateCombo() {
            const now = Date.now();
            if (now - lastHitTime > 2000) {
                combo = 0;
            }
            combo++;
            lastHitTime = now;

            if (combo > maxCombo) {
                maxCombo = combo;
            }

            comboElement.textContent = combo;

            // Show combo display for high combos
            if (combo >= 5) {
                comboDisplayElement.textContent = `${combo}x COMBO!`;
                comboDisplayElement.style.display = 'block';
                comboDisplayElement.style.color = combo >= 10 ? '#ff4757' : '#ffd700';

                setTimeout(() => {
                    comboDisplayElement.style.display = 'none';
                }, 1500);
            }
        }

        function updatePowerUpDisplay() {
            let status = '';
            const now = Date.now();

            if (activePowerUps.widePaddle > now) {
                const remaining = Math.ceil((activePowerUps.widePaddle - now) / 1000);
                status += `Wide: ${remaining}s `;
            }
            if (activePowerUps.bigBall > now) {
                const remaining = Math.ceil((activePowerUps.bigBall - now) / 1000);
                status += `Big: ${remaining}s `;
            }
            if (activePowerUps.laser > now) {
                const remaining = Math.ceil((activePowerUps.laser - now) / 1000);
                status += `Laser: ${remaining}s `;
            }
            if (activePowerUps.fireBall > now) {
                const remaining = Math.ceil((activePowerUps.fireBall - now) / 1000);
                status += `Fire: ${remaining}s `;
            }
            if (activePowerUps.multiball.length > 0) {
                status += `Multi `;
            }
            powerUpStatusElement.textContent = status;
        }

        function updatePowerUps() {
            // Update power-up positions and effects
            powerUps.forEach((powerUp, index) => {
                powerUp.y += powerUp.dy;
                powerUp.pulse += 0.1;

                // Check collision with paddle
                if (powerUp.y + powerUp.height > paddle.y &&
                    powerUp.x + powerUp.width > paddle.x &&
                    powerUp.x < paddle.x + paddle.width) {
                    activatePowerUp(powerUp);
                    powerUps.splice(index, 1);
                }

                // Remove if off screen
                if (powerUp.y > canvas.height) {
                    powerUps.splice(index, 1);
                }
            });

            // Check power-up expiration
            const now = Date.now();

            if (activePowerUps.widePaddle > 0 && activePowerUps.widePaddle < now) {
                paddle.width = paddle.originalWidth;
                activePowerUps.widePaddle = 0;
            }

            if (activePowerUps.bigBall > 0 && activePowerUps.bigBall < now) {
                ball.radius = ball.originalRadius;
                activePowerUps.bigBall = 0;
            }

            if (activePowerUps.laser > 0 && activePowerUps.laser < now) {
                canShootLaser = false;
                paddle.glowing = false;
                activePowerUps.laser = 0;
                updateLaserButtonGlow();
            }

            if (activePowerUps.fireBall > 0 && activePowerUps.fireBall < now) {
                ball.fireBall = false;
                activePowerUps.fireBall = 0;
            }

            updatePowerUpDisplay();
        }

        function updateTrails() {
            // Update ball trail
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 10) ball.trail.shift();

            // Update multiball trails
            activePowerUps.multiball.forEach(multiBall => {
                multiBall.trail.push({ x: multiBall.x, y: multiBall.y });
                if (multiBall.trail.length > 8) multiBall.trail.shift();
            });

            // Update paddle trail
            paddle.trail.push({ x: paddle.x + paddle.width / 2, y: paddle.y });
            if (paddle.trail.length > 5) paddle.trail.shift();
        }

        function updateParticles() {
            // Update particles
            particles.forEach((particle, index) => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.life -= particle.decay;
                particle.dy += 0.2; // Gravity

                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Update explosions
            explosions.forEach((explosion, index) => {
                explosion.radius += 3;
                explosion.life -= explosion.decay;

                if (explosion.life <= 0 || explosion.radius > explosion.maxRadius) {
                    explosions.splice(index, 1);
                }
            });
        }

        function checkCollisions() {
            const allBalls = [ball, ...activePowerUps.multiball];

            allBalls.forEach((currentBall, ballIndex) => {
                // Ball-brick collisions
                bricks.forEach((brick, brickIndex) => {
                    if (!brick.visible || brick.animating) return;

                    if (currentBall.x - currentBall.radius < brick.x + brick.width &&
                        currentBall.x + currentBall.radius > brick.x &&
                        currentBall.y - currentBall.radius < brick.y + brick.height &&
                        currentBall.y + currentBall.radius > brick.y) {

                        // Handle collision
                        if (brick.type === 'unbreakable' && !currentBall.fireBall) {
                            // Bounce off unbreakable bricks
                            currentBall.dy = -currentBall.dy;
                            playSound(300, 0.1, 'square');
                            return;
                        }

                        // Reduce brick health
                        if (currentBall.fireBall || brick.type !== 'unbreakable') {
                            brick.hits--;

                            if (brick.hits <= 0) {
                                // Brick destroyed
                                brick.visible = false;
                                score += brick.points * (combo + 1);
                                scoreElement.textContent = score;

                                updateCombo();
                                createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 8);
                                createPowerUp(brick.x + brick.width/2, brick.y + brick.height/2);

                                if (brick.type === 'explosive') {
                                    createExplosion(brick.x + brick.width/2, brick.y + brick.height/2);
                                    // Damage nearby bricks
                                    bricks.forEach(nearbyBrick => {
                                        if (nearbyBrick.visible && nearbyBrick !== brick) {
                                            const dx = nearbyBrick.x + nearbyBrick.width/2 - (brick.x + brick.width/2);
                                            const dy = nearbyBrick.y + nearbyBrick.height/2 - (brick.y + brick.height/2);
                                            const distance = Math.sqrt(dx*dx + dy*dy);
                                            if (distance < 80) {
                                                nearbyBrick.hits--;
                                                if (nearbyBrick.hits <= 0) {
                                                    nearbyBrick.visible = false;
                                                    score += nearbyBrick.points;
                                                    scoreElement.textContent = score;
                                                    createParticles(nearbyBrick.x + nearbyBrick.width/2, nearbyBrick.y + nearbyBrick.height/2, nearbyBrick.color, 6);
                                                }
                                            }
                                        }
                                    });
                                    playSound(200, 0.3, 'sawtooth', 0.1);
                                } else {
                                    playSound(600 + Math.random() * 200, 0.1, 'square');
                                }
                            } else {
                                // Brick damaged but not destroyed
                                playSound(400, 0.1, 'triangle');
                                createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 3);
                            }

                            // Bounce ball (unless it's a fire ball)
                            if (!currentBall.fireBall) {
                                // Determine bounce direction
                                const ballCenterX = currentBall.x;
                                const ballCenterY = currentBall.y;
                                const brickCenterX = brick.x + brick.width / 2;
                                const brickCenterY = brick.y + brick.height / 2;

                                const deltaX = ballCenterX - brickCenterX;
                                const deltaY = ballCenterY - brickCenterY;

                                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                    currentBall.dx = -currentBall.dx;
                                } else {
                                    currentBall.dy = -currentBall.dy;
                                }
                            }
                        }
                    }
                });

                // Ball-paddle collision
                if (currentBall.y + currentBall.radius > paddle.y &&
                    currentBall.y - currentBall.radius < paddle.y + paddle.height &&
                    currentBall.x + currentBall.radius > paddle.x &&
                    currentBall.x - currentBall.radius < paddle.x + paddle.width) {

                    // Calculate hit position relative to paddle center
                    const hitPos = (currentBall.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);

                    // Adjust ball direction based on hit position
                    currentBall.dx = hitPos * currentBall.speed * 0.75;
                    currentBall.dy = -Math.abs(currentBall.dy);

                    // Add some variation to prevent infinite loops
                    if (Math.abs(currentBall.dx) < 1) {
                        currentBall.dx = currentBall.dx > 0 ? 1 : -1;
                    }

                    currentBall.y = paddle.y - currentBall.radius;
                    playSound(800, 0.1, 'sine');
                    createParticles(currentBall.x, currentBall.y, '#fff', 5);
                }

                // Wall collisions
                if (currentBall.x - currentBall.radius <= 0 || currentBall.x + currentBall.radius >= canvas.width) {
                    currentBall.dx = -currentBall.dx;
                    currentBall.x = currentBall.x - currentBall.radius <= 0 ? currentBall.radius : canvas.width - currentBall.radius;
                    playSound(400, 0.1, 'triangle');
                }

                if (currentBall.y - currentBall.radius <= 0) {
                    currentBall.dy = -currentBall.dy;
                    currentBall.y = currentBall.radius;
                    playSound(400, 0.1, 'triangle');
                }

                // Ball fell off bottom
                if (currentBall.y > canvas.height) {
                    if (ballIndex === 0) {
                        // Main ball fell
                        lives--;
                        livesElement.textContent = lives;
                        playSound(200, 0.5, 'sawtooth');

                        if (lives <= 0) {
                            endGame();
                            return;
                        } else {
                            resetBallPosition();
                        }
                    } else {
                        // Multiball fell
                        activePowerUps.multiball.splice(ballIndex - 1, 1);
                    }
                }

                // Stuck ball detection
                if (Math.abs(currentBall.dx) < 0.5 && currentBall.dy > 0) {
                    currentBall.stuckCounter++;
                    if (currentBall.stuckCounter > 120) { // 2 seconds at 60fps
                        currentBall.dx = (Math.random() > 0.5 ? 1 : -1) * currentBall.speed * 0.7;
                        currentBall.stuckCounter = 0;
                    }
                } else {
                    currentBall.stuckCounter = 0;
                }
            });

            // Laser-brick collisions
            lasers.forEach((laser, laserIndex) => {
                bricks.forEach((brick, brickIndex) => {
                    if (!brick.visible || brick.animating) return;

                    if (laser.x < brick.x + brick.width &&
                        laser.x + laser.width > brick.x &&
                        laser.y < brick.y + brick.height &&
                        laser.y + laser.height > brick.y) {

                        if (brick.type !== 'unbreakable') {
                            brick.hits--;

                            if (brick.hits <= 0) {
                                brick.visible = false;
                                score += brick.points * (combo + 1);
                                scoreElement.textContent = score;
                                updateCombo();
                                createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 6);
                                createPowerUp(brick.x + brick.width/2, brick.y + brick.height/2);

                                if (brick.type === 'explosive') {
                                    createExplosion(brick.x + brick.width/2, brick.y + brick.height/2);
                                    playSound(200, 0.3, 'sawtooth');
                                } else {
                                    playSound(700, 0.1, 'square');
                                }
                            } else {
                                playSound(500, 0.1, 'triangle');
                                createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 3);
                            }
                        }

                        lasers.splice(laserIndex, 1);
                    }
                });
            });
        }

        function resetBallPosition() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
            ball.dy = -ball.speed;
            ball.trail = [];
        }

        function checkWaveComplete() {
            const remainingBricks = bricks.filter(brick => brick.visible && brick.type !== 'unbreakable').length;

            if (remainingBricks === 0) {
                wave++;
                waveElement.textContent = wave;

                // Bonus points for completing wave
                const waveBonus = wave * 100;
                score += waveBonus;
                scoreElement.textContent = score;

                playSound(800, 0.5, 'sine');
                startWaveTransition();
            }
        }

        function updateMovement() {
            // Desktop movement
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                paddle.x -= paddle.speed;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                paddle.x += paddle.speed;
            }

            // Mobile movement
            if (touchControls.left) {
                paddle.x -= paddle.speed;
            }
            if (touchControls.right) {
                paddle.x += paddle.speed;
            }

            // Keep paddle within bounds
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

            // Update ball positions
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Update multiball positions
            activePowerUps.multiball.forEach(multiBall => {
                multiBall.x += multiBall.dx;
                multiBall.y += multiBall.dy;
            });

            // Update laser positions
            lasers.forEach((laser, index) => {
                laser.y += laser.dy;
                if (laser.y + laser.height < 0) {
                    lasers.splice(index, 1);
                }
            });

            // Update laser cooldown
            if (laserCooldown > 0) {
                laserCooldown--;
            }
        }

        function drawPaddleGlow() {
            if (paddle.glowing && canShootLaser) {
                const now = Date.now();
                const glowIntensity = 0.5 + 0.3 * Math.sin(now * 0.01);

                // Create gradient for glow effect
                const gradient = ctx.createRadialGradient(
                    paddle.x + paddle.width / 2, paddle.y + paddle.height / 2, 0,
                    paddle.x + paddle.width / 2, paddle.y + paddle.height / 2, paddle.width * 0.8
                );
                gradient.addColorStop(0, `rgba(0, 255, 255, ${glowIntensity})`);
                gradient.addColorStop(0.7, `rgba(0, 255, 255, ${glowIntensity * 0.3})`);
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(
                    paddle.x - paddle.width * 0.3,
                    paddle.y - paddle.height * 0.5,
                    paddle.width * 1.6,
                    paddle.height * 2
                );

                // Add particle effects around paddle
                if (Math.random() < 0.3) {
                    const particleX = paddle.x + Math.random() * paddle.width;
                    const particleY = paddle.y + Math.random() * paddle.height;
                    particles.push({
                        x: particleX,
                        y: particleY,
                        dx: (Math.random() - 0.5) * 2,
                        dy: -Math.random() * 3,
                        color: '#00ffff',
                        life: 0.8,
                        decay: 0.02,
                        size: 1 + Math.random() * 2
                    });
                }
            }
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw paddle glow first (behind paddle)
            drawPaddleGlow();

            // Draw paddle trail
            ctx.globalAlpha = 0.3;
            paddle.trail.forEach((point, index) => {
                const alpha = index / paddle.trail.length;
                ctx.globalAlpha = alpha * 0.3;
                ctx.fillStyle = paddle.color;
                ctx.fillRect(point.x - paddle.width/2, point.y, paddle.width, paddle.height);
            });
            ctx.globalAlpha = 1;

            // Draw paddle
            ctx.fillStyle = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

            // Draw ball trail
            ctx.globalAlpha = 0.5;
            ball.trail.forEach((point, index) => {
                const alpha = index / ball.trail.length;
                const radius = ball.radius * alpha;
                ctx.globalAlpha = alpha * 0.5;
                ctx.fillStyle = ball.fireBall ? '#ff4757' : '#fff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw ball
            ctx.fillStyle = ball.fireBall ? '#ff4757' : '#fff';
            if (ball.fireBall) {
                // Add fire effect
                const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius * 2);
                gradient.addColorStop(0, '#ffff00');
                gradient.addColorStop(0.5, '#ff4757');
                gradient.addColorStop(1, '#ff1744');
                ctx.fillStyle = gradient;
            }
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw multiball
            activePowerUps.multiball.forEach(multiBall => {
                // Draw trail
                ctx.globalAlpha = 0.4;
                multiBall.trail.forEach((point, index) => {
                    const alpha = index / multiBall.trail.length;
                    const radius = multiBall.radius * alpha;
                    ctx.globalAlpha = alpha * 0.4;
                    ctx.fillStyle = '#ff9ff3';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw ball
                ctx.fillStyle = '#ff9ff3';
                ctx.beginPath();
                ctx.arc(multiBall.x, multiBall.y, multiBall.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw bricks
            bricks.forEach(brick => {
                if (!brick.visible) return;

                ctx.fillStyle = brick.color;

                // Add visual feedback for damaged bricks
                if (brick.hits < brick.maxHits && brick.maxHits > 1) {
                    const damage = 1 - (brick.hits / brick.maxHits);
                    ctx.globalAlpha = 1 - damage * 0.3;
                }

                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

                // Draw border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);

                // Draw hit indicators for multi-hit bricks
                if (brick.maxHits > 1) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(brick.width, brick.height) * 0.4}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        brick.hits.toString(),
                        brick.x + brick.width / 2,
                        brick.y + brick.height / 2
                    );
                }

                ctx.globalAlpha = 1;
            });

            // Draw lasers
            lasers.forEach(laser => {
                const gradient = ctx.createLinearGradient(laser.x, laser.y, laser.x, laser.y + laser.height);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(0.5, '#00d2d3');
                gradient.addColorStop(1, '#0099cc');
                ctx.fillStyle = gradient;
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);

                // Add glow effect
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                ctx.shadowBlur = 0;
            });

            // Draw power-ups
            powerUps.forEach(powerUp => {
                const pulseSize = 1 + Math.sin(powerUp.pulse) * 0.2;
                const size = Math.min(powerUp.width, powerUp.height) * pulseSize;

                ctx.fillStyle = powerUp.color;
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.width / 2,
                    powerUp.y + powerUp.height / 2,
                    size / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Draw symbol
                ctx.fillStyle = '#fff';
                ctx.font = `${size * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerUp.symbol,
                    powerUp.x + powerUp.width / 2,
                    powerUp.y + powerUp.height / 2
                );
            });

            // Draw particles
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw explosions
            explosions.forEach(explosion => {
                const alpha = explosion.life;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ff4757';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.globalAlpha = alpha * 0.3;
                ctx.fillStyle = '#ff4757';
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function gameLoop() {
            if (!gameRunning || gamePaused) return;

            updateMovement();

            if (!waveTransitioning) {
                checkCollisions();
                checkWaveComplete();
                updatePowerUps();
                updateTrails();
                updateParticles();
                animateBricksIn();
                updateLiveStats();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            finalScoreElement.textContent = score;
            finalWaveElement.textContent = wave;
            maxComboElement.textContent = maxCombo;

            // Check and update best score
            checkAndUpdateBestScore(score);
            gameOverBestScoreElement.textContent = bestScore;

            gameOverDiv.style.display = 'block';
            playSound(150, 1, 'sawtooth', 0.2);
        }

        function restartGame() {
            // Reset game state
            score = 0;
            lives = 3;
            wave = 1;
            combo = 0;
            maxCombo = 0;
            gameStartTime = Date.now();

            // Reset UI
            scoreElement.textContent = score;
            livesElement.textContent = lives;
            comboElement.textContent = combo;
            waveElement.textContent = wave;
            gameOverDiv.style.display = 'none';

            // Reset game objects
            initializePositions();
            resetBallPosition();

            // Clear arrays
            bricks = [];
            animatingBricks = [];
            powerUps = [];
            lasers = [];
            particles = [];
            explosions = [];

            // Reset power-ups
            activePowerUps = {
                widePaddle: 0,
                bigBall: 0,
                extraLife: false,
                multiball: [],
                laser: 0,
                fireBall: 0
            };
            pausedPowerUpTimes = {
                widePaddle: 0,
                bigBall: 0,
                laser: 0,
                fireBall: 0
            };

            // Reset paddle and ball properties
            paddle.width = paddle.originalWidth;
            paddle.glowing = false;
            ball.radius = ball.originalRadius;
            ball.fireBall = false;
            canShootLaser = false;
            laserCooldown = 0;

            updateLaserButtonGlow();
            updatePowerUpDisplay();

            // Start first wave
            startWaveTransition();

            // Start game loop
            gameLoop();
        }

        // Initialize the game
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            initializePositions();
            calculateBrickDimensions();
        });

        // Start the game when ready
        if (audioContext && audioContext.state === 'suspended') {
            // Resume audio context on first user interaction
            document.addEventListener('click', () => {
                audioContext.resume();
            }, { once: true });
        }
    </script>
</body>
</html>